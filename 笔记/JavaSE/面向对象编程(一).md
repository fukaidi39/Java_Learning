### 一、类与对象

> 模块化设计，具有封装性、继承性与多态性；类相当于引用数据类型

**注意：区别public class 与 class:**

public class:

> - public class 类名必须与文件名保持一致，每个文件**至多一个**
> - 被public 修饰的类可以被其他包访问

class:

> - class类可以访问public类，但不能被其他包访问

**问：区分堆内存和栈内存？**

> 堆内存：保存对象的具体信息，在程序中堆内存的开辟通过new来完成
>
> 栈内存：保存的是一块堆内存的地址，即通过地址找到堆内存，而后找到对象内容。一个栈内存只能保存一个堆内存地址数据。

#### 1.1类与对象的定义及使用

> 类：类是对某一类事物共性的抽象描述，是一个模板。由两部分组成：
>
> - 成员属性(Field):一个人的年龄、姓名
> - 操作方法(Method):对象具有的处理行为

```java
class Person{
    String name;   //默认“”
    int age;       //默认0
    public void getMessage(){
        System.out.println("姓名:"+name+"\t"+"年龄："+age);
    }
}
```

对象：描述的是一个具体的产物，是一个使用的实例。产生对象有两种方法：

> - 声明并实例化对象：类名称  对象名称= new 类名称()
> - 分步骤：
>   - 声明对象：类名称  对象名称 = null；
>   - 实例化对象：对象名称 = new 类名称();

```java
Person per = new Person();  //声明并实例化对象
Person per_1 = null;  //开栈空间，保存名字为per_1,无指向
per_1 = new Person(); //开堆内存，将地址保存入栈，此时per_1指的是堆内存地址
```

使用对象操作类：

> - 调用类中属性：实例化对象.成员属性 = 内容;
> - 调用类中方法：实例化对象.方法名称();

```java
per.name = "Didi";
per.getMessage();
```

#### 1.2对象引用传递

> 同一块堆内存空间被不同栈内存指向

```java
Person per_1 = new Person();
per_1.name = "张三";
per_1.age = 18;
Person per_2 = per_1;   //开辟新栈内存，并将per_1地址赋给per_2
per_2.age = 80;
per_1.getMessage();    //（张三，80岁）
```

> 除在主方法定义外，也可通过方法实现引用传递

```java
public static void changeInfo(Person temp){
    temp.age = 80;
}
changeInfo(per_1);
```

#### 1.3垃圾空间

> 没有栈内存指向的堆内存空间都是垃圾空间，所有的垃圾将被GC(Garbage Collector)不定期回收，并且释放无用空间

### 二、成员属性封装

> 对类的属性进行保护，一旦封装对类外部属性不可见，但对类内部是可见的。

```java
private String name ;
private int age;

per.name = "didi";   //由于封装，不可使用
```

#### 2.1设置setter()和getter()

```java
public void setName(String name){
    this.name = name;
}
public String getName(){
    return name;
}
public void setAge(int age){
	this.nge = age;
}
public int getAge(){
    return age;
}
```

#### 2.2构造方法

> 可以通过构造方法实现对象的初始化处理

- 构造方法的名称与类名称一致
- 构造方法不允许设置任何返回值类型，没有返回值
- 构造方法是在new实例化对象后自动调用的
- 结论：一个类至少存在一个构造方法，永恒存在(给定默认值)

```java
public Person(String name,int age){
    this.name = name;
    this.age = age;
}

Person per = new Person("didi",22)
```

构造方法重载：

> 按参数多少升序排列，定义多种初始化方式

```java
public Person(int age){
    this.name = "无名氏";
    this.age = age;
}
public Person(String name,int age){
    this.name = name;
    this.age = age;
}
```

**问：构造方法不返回值，为什么不用void?**

> 编辑器为了区分开普通方法和构造方法。构造方法是在实例化对象时调用的；普通方法是在实例化对象后调用的。

**问：setter()和构造方法的区别？**

> 构造方法：对象属性初始化
>
> setter():除初始化外还能修改数据

#### 2.3匿名对象

> 匿名对象在创建对象时只通过new开辟了堆内存，却没有把堆内存地址赋给栈内存的某个变量用于存储。对象使用一次后成为垃圾被GC回收释放。

```java
new Person("张三"，20).getMessaage();
```


### 三、this 和 static 关键字

#### 3.1this关键字

- 当前类中的属性：this.属性；

> Java中变量取用以{}为边界就近取用
>
> **开发中：访问本类中属性时，一定要加this实现访问**

```java
public Person(String name, int age){
    this.name = name;
    this,age = age;
}
public void getMessage(){
    System.out.println("姓名："+this.name+"、年龄："+this.age)
}
```

- 当前类中的方法(普通方法、构造方法)：

  > 构造方法（this()）:使用关键字new实例化对象时调用
  >
  > 普通方法（this.方法名称()）:实例化对象之后

```java
	public Person() {
		System.out.println("成功实例化了一个对象。");
	}
	public Person(String name) {
		this();       //必须位于构造方法的首行
		this.name = name;
	}
	public Person(String name,int age) {
		this(name);
		this.age = age;
	}
```

> 构造方法互相调用时保留程序出口，别形成死循环

```java
public Person(String name,int age){
    this.setName(name);
    this.setAge(age);    //加与不加都表示本类方法
}
```

构造方法互相调用消灭重复代码案例：

> 要求：定义一个描述员工信息的程序类，该类中提供有：编号、姓名、部门、工资
>
> [无参构造]：编号定义为1000，姓名为无名氏；
>
> [单参构造]：传递编号，姓名定义为“无名氏”，部门为“未定”，工资为0.0；
>
> [三参构造]：传递编号、姓名、部门，工资为2500.00；
>
> [四参构造]：所有属性进行传递。

```java
public class Emp {
	private long empno;
	private String ename;
	private String dept;
	private double salary;
	
	public String getInfo() {
		return "雇员编号："+this.empno+
			   "、雇员姓名："+this.ename+
			   "、部门："+this.dept+
			   "、薪水："+this.salary;
	}
	public Emp() {
		this(1000L,"无名氏",null,0.00);   //调用四参构造方法
	}
	public Emp(long empno) {
		this(empno,"无名氏","未定",0.0);   //调用四参构造方法
	}
	public Emp(long empno, String ename, String dept) {
		this(empno,ename,dept,2500);     //调用四参构造方法
	}
	public Emp(long empno, String ename, String dept, double salary) {
		this.empno = empno;
		this.ename = ename;
		this.dept = dept;
		this.salary = salary;
	}
}
```

- 描述当前对象

#### 3.2简单JAVA类

> 描述某一类信息的程序类，如描述一个人、一本书。

- 类名称一定要有意义，可以明确描述某一类事物
- 类中所有属性用private封装，同时封装后的属性必须提供setter()和getter()
- 类中可以提供无数多个构造方法，但是必须保留无参构造方法
- 类中不允许出现任何输出语句，所有的获取必须返回
- **[非必须]**可以提供一个获取详细信息的方法getInfo()

```java
public class Dept {
	private long Dno;
	private String Dname;
	private String loc;
	//定义setter()和getter()
	public void setDno(long Dno) {
		this.Dno = Dno;
	}
	public long getDno() {
		return this.Dno;
	}
	public void setDname(String Dname) {
		this.Dname = Dname;
	}
	public String getDname() {
		return this.Dname;
	}
	public void setLoc(String loc) {
		this.loc = loc;
	}
	public String getLoc() {
		return this.loc;
	}
	
	public Dept() {  //定义无参构造
	}
	public Dept(long Dno, String Dname, String loc) {
		this.Dno = Dno;
		this.Dname = Dname;
		this.loc = loc;
	}
	
	public String getInfo() {
		return "部门编号："+this.Dno+"、部门名称："+this.Dname+"、部门地址："+this.loc;
	}
}
```

#### 3.3Static关键字

> 主要定义属性和方法

- static定义公共属性，内存在全局数据区。修改一个对象属性，所有对象的属性内容都发生变化

> 注意：由于其本身是一个公共属性，最好通过类名称直接调用。
>
> static属性虽然定义在类之中，但是其并不受到类实例化对象的控制。static属性可以在没有实例化对象的时候使用。

```java
static String country = "中华民国";
---------------------------------
Person.country = "中华人民共和国";    //修改公共属性
Person per = new Person("张三",22);
System.out.println(per.getInfo());
```

**类设计时首选非static属性，而考虑到公共信息存储的时候才会使用到static属性。**

> 非static属性要在实例化对象之后使用，而static属性可以在没有实例化对象的情况下直接通过类名称进行调用。



- static定义方法：其主要特点在于可以直接由类名称在没有实例化对象的情况下进行调用。

> - static方法只允许调用static属性或static方法; 调用非static方法需要实例化
> - 非static方法允许调用static属性或static方法;

```java
public static void setCountry(String c){
    country = c;   //不能用this.country = country;static方法可以不由实例化对象问，冲突了
    name = "sss"; //不能调用非static属性    可用 Person.name = "sss"
    getInfo();    //不能调用非static方法
}
----------------------------------------
    Person.setCountry("宁波");
```

> 所有static定义的属性和方法都可以在没有实例化对象的前提下使用，而所有非static定义的属性和方法必须在实例化对象的情况下才可以使用。

```java
public class Testdemo {
	public static void main(String[] args) {
		getMessage();
		new Testdemo().getMessage1();  //匿名对象实例化后才能调用普通方法
	}
	
	public static void getMessage() {
		System.out.println("静态方法调用");
	}
	public void getMessage1() {
		System.out.println("非static方法调用");
	}
}
```

​		**总结：static定义属性和方法在编写代码之初不考虑，只有在回避实例化对象调用并且描述公共属性时考虑。**

----

范例：编写一个程序类，这个类可以实现实例化对象个数的统计。

```java
public class Book {
	private String title;
	private static int count = 0;
	
	public Book(String title) {
		this.title = title;
		count++;
		System.out.println("第"+count+"本图书被创建，名称是"+this.title);
	}
}
-----------------------------------------------------------------------
    new Book("Java");    //创建匿名类对象
	new Book("C++");
	new Book("Python");
```

范例：实现属性的自动命名处理，没有命名的采用NOTITLE-编号的方式。

```java
public Book() {
	this("Notitle-"+ count++);    //利用this调用当前类中的构造方法
}
public Book(String title) {
	this.title = title;
}
```

#### 3.4代码块

> 普通代码块、构造块、静态块与同步代码块:{}

- 普通代码块

> 可以在一个方法(方法长)之中进行一些结构的拆分，以防止相同变量名称所带来的互相影响

```java
public static void main(String[] args){
    int x = 1000;   //相当于内部是全局变量
    {
    int x = 10;   //局部变量
    System.out.println("x= "+x);
    }
    System.out.println("x= "+x);
}
```

- 构造块

> 构造块优先于构造方法执行,每一次实例化新对象时都会调用构造块中代码

```java
class Person{
    public Person(){
        System.out.println("构造方法");
    }
    {
        System.out.println("构造块");
    }
}
```

- 静态代码块

> 用static定义的代码块，分为主类中和非主类中定义的静态块

非主类中的静态块：

> 静态代码块优先于构造块执行。不管有多少实例化对象，都仅执行一次
>
> 主要目的是为类中的静态属性初始化

```java
class Person{
    private static String country;
    static{        //初始化静态属性
        country = Message.getCountry();//编写一部分代码(很多语句)
    }
}
```

主类中的静态块：

> 静态代码块优先于主方法先执行。帮助你实现准备过程。

```java
public class TestDemo{
    public static void main(String[] args){
        System.out.println("主程序执行。")
    }
    static{
        System.out,println("程序初始化")
    }
}
```

### 四、Java类案例分析

- **Address类**：编写并测试一个代表地址的Address类，地址信息由国家、省市、城市、街道、邮编组成，并可以返回完整的地址信息。

> 利用简单Java类，属性+构造方法+getter和setter+方法

- **Employee类：**定义并测试一个代表员工的Employee类。员工属性包括“编号”、“姓名”、“基本薪水”、“薪水增长率”，并且包括薪水增长额以及计算增长后的工资总额的操作。

```java
public double salaryIncValue() {
	return this.salary * this.rate;
}
public double salaryIncResult() {
	this.salary = this.salary + this.salaryIncValue();    //调用本类方法
	return this.salary;
}
```

- **Dog类：**设计一个Dog类，有名字、颜色、年龄等属性，定义构造方法来初始化这些属性

> 简单Java类

- **Account类：**构造一个银行账户类

(1)数据成员用户的账户名称、用户的账户余额;(2)方法包括开户;(3)查询余额

```java
public Account() {
}
public Account(String name) {
	this(name,0.0);    //开户
}
public Account(String name, double balance) {
	this.name = name;
	this.balance = balance;
}
//getter与setter
public double getBalance() {
	return this.balance;     //查询余额
}
```

- **User类：**设计一个表示用户的User类，类中的属性有用户名、密码和记录用户个数的变量，定义三个构造方法(无参、为用户名赋值、为用户名和密码赋值)，获取和设置密码的方法和返回类信息的方法

```java
private static int number = 0;
---------------------------------	
public User() {	
	this("NoID","123456");
}
public User(String uid) {
	this(uid,"123456");
}
public User(String uid, String password) {
	this.uid = uid;
	this.password = password;
	number++;
}
public static int getNumber() {  //获取用户个数
	return number;
}
```

- **Book类：**声明一个图书类，其数据成员为书名、编号(利用静态变量自动编号)、书价、图书总量，在构造方法中利用此静态变量为对象的编号赋值，在主方法中定义多个对象，并求出总册数。

```java
private String title;   //书名
private double price;   //价格
private int bid;  //编号
private static int count = 0;
public Book() {	
	}
public Book(String title, double price) {
	this.title = title;
	this.price = price;
	this.bid = count+1;
	count++;
}
public static int getCount() {
	return count;   //统计总数用静态方法
}
public String getInfo() {
	return "编号："+this.bid+"\t书名："+this.title+"\t价格："+this.price;
}
```

### 五、数组

#### 5.1数组的基本定义

> 定义数组：Java中将数组定义为了引用数据类型，涉及内存分配，用new来处理

- 数组的动态初始化：初始化之后数组每一个元素的保存内容为其对应数据类型的默认值
  - 声明并初始化数组：
    - 数据类型 数组名称[] = new 数据类型[长度]；
    - 数据类型 [] 数组名称 = new 数据类型[长度]；
- 数组的静态初始化：定义时已经设置好了内容
  - 简化格式：数据类型 数组名称[] = {数据}
  - 完整格式：数据类型 数组名称[] = **new 数据类型 []{数据}**

```java
int data[] = new int [3];  //动态初始化
data [0] = 1; //设置内容
data [1] = 2;
data [2] = 3;
```

> 数组的使用：

- 数组名称[下标]：下标从0开始—数组长度-1

- 使用循环操作数组

```java
int data[] = new int[]{1,2,3};  //静态初始化
for(int i=0; i<data.length; i++) {
	System.out.println(data[i]);
}
```

- 数组名称.length访问数组长度

#### 5.2数组的引用传递

> 利用new开辟堆内存空间，同时开辟栈内存(名称为数组名称)保存地址。既然数组是引用数据类型，那么一个堆内存可以被多个栈内存所指向。

```java
int data [] = new int[]{1,2,3};
int temp []= data;   //引用传递
temp [0]= 99;
for (int i=0; i<data.length; i++){
    System.out.println(data[i]);
}
```

> 数组是引用数据类型(类与对象同)，必须开辟堆内存后才能操作(否则NullPointerException)。

#### 5.3foreach迭代输出

> 传统for循环遍历数组需要处理下标，如果处理不当容易越界。因此引入增强型foreach

- 定义：for (数据类型 变量 ：数组 | 集合){ }

​      最大的特点在于将数组中的每一个元素取出，保存在变量里，可以通过变量获取数组内容，而避免下标的方式。

```java
int data[] = new int[]{1,2,3,4,5};
for(int temp : data) {     //定义数组中变量
	System.out.println(temp);
}
```

#### 5.4二维数组

> 通过行列下标同时定义

- 数组的动态初始化
  - 数据类型 数组名称 [] [] = new 数据类型 [行个数] [列个数]；
- 数组的静态初始化
  - 数据类型 数组名称 [] [] = new 数据类型 [] []{{数据，数据}，{数据，数据}，{数据，数据}}

**传统方法遍历：**

```java
	int data[][] = new int[][] {
		{1,2,4},{2,4,6},{3,4,1,5,6}};
	for(int i=0;i<data.length;i++) {
		for(int j=0;j<data[i].length;j++) {
			System.out.println("data["+i+"]["+j+"] = "+data[i][j]);
		}
	}
```

**用foreach遍历：**

```java
for(int temp[] : data) {     //定义数组变量
	for(int num: temp) {     //定义变量
		System.out.print(num+"、");
	}
	System.out.println();
}
```

#### 5.5数组与方法

> 数组本身属于引用数据类型，可以实现方法的引用传递操作(同一块堆内存被不同的栈内存所指向)
>
> 方法结束后，该方法栈内存收进GC

```java
public class ArrayDemo {
	public static void main(String[] args) {
		int arr [] = initArray();
		changeArray(arr);
		printArray(arr);
	}
	public void printArray(int temp[]) {     //接收数组
		for(int num: temp) {
			System.out.println(num);
		}
	}
   	public static int[] initArray() {        //返回数组
		int temp[] = new int[] {1,2,3,4,5} ;
   	    return temp;      //此时temp即数组变量
	}
    public static void changeArray(int temp[]) {    //修改数组(无法通过foreach)
		for(int x = 0;x<temp.length;x++) {
    	temp[x] *=2;
		}
	}
}
```

**注意：**foreach不可以**改变变量**，即使用集合存变量也不可以(foreach循环中，是把容器中的数据交给了那个element，当容器中装的是变量时，foreach是改变不了元数据的，想改变只能通过for循环)。

**范例：求一个int数组的总和、平均、最大、最小值？**

```java
public class ArrayUtil {
	private int sum ;
	private double Avg;
	private int max;
	private int min;
	
	public ArrayUtil(int arr[]) {  //输入是一个任意数组
		//在构造方法中操作类，表明在实例化对象时操作
		sum = 0; Avg = 0.0; max = arr[0]; min = arr[0];
		for(int i=0; i< arr.length; i++) {
			this.sum += arr[i];
			if(arr[i] > max) {
				this.max = arr[i];
			}
			if(arr[i] < min) {
				this.min = arr[i];
			}
		}
		this.Avg = this.sum / arr.length;
	}
    //定义获取值的getter
	public int getSum() {
		return this.sum;
	}
	public double getAvg() {
		return this.Avg;
	}
	public int getMax() {
		return this.max;
	}
	public int getMin() {
		return this.min;
	}
}
-----------------------------------------------------------------
int arr[] = new int[] {1,4,6,8,9};
ArrayUtil util = new ArrayUtil(arr);
System.out.println("数组总和："+util.getSum());
System.out.println("数组平均值："+util.getAvg());
System.out.println("数组最大值："+util.getMax());
System.out.println("数组最小值："+util.getMin());
```

**案例：数组排序**

> **注意：**在以后进行类设计的时候，如果类中没有属性存在的意义，那么定义的方法就没有必要使用普通方法了，因为普通方法需要在有实例化对象产生的情况下才可以调用。

```java
public static void sort(int arr[]) {//未使用属性
	for(int j=0; j<arr.length; j++) {
		for(int i=0; i< arr.length-j-1; i++) {
			if(arr[i+1] < arr[i]) {
				//相邻交换位置
				int temp = arr[i];
				arr[i] = arr[i+1];
				arr[i+1] = temp;
			}
        }
	}
}
```

**案例：数组翻转**

小心：int temp[] = arr:表示的是引用传递，两个栈内存指向同一个堆内存数据空间；

而arr =  temp:将产生垃圾。

```java
	public static void reverse(int arr[]) {
		//交换次数，定义为整型舍去小数		
		int center = arr.length/2;  
		int foot = arr.length-1;
		for(int i=0;i<center;i++) {
			//交换位置
			int temp = arr[i];
			arr[i] = arr[foot-i];
			arr[foot-i] = temp;
		}
	}
```

#### 5.6数组相关类库

> 操作数组下标相关多用循环

- 排序

```java
java.util.Arrays.sort(arr);   //排序
```

- 数组拷贝：System.arraycopy(源数组，源数组开始点，目标数组，目标数组开始点，拷贝长度)

  > 即从源数组截一段替换目标数组

```java
int dataA[] = new int[] {1,2,3,4,5,6,7,8,9};
int dataB[] = new int[] {11,22,33,44,55,66,77,88,99};
System.arraycopy(dataA, 3, dataB, 3, 5);
ArrayUtil.printArray(dataB);
---------------------------------------------------
->11、22、33、4、5、6、7、8、99
```

#### 5.7方法可变参数

> 从JDK1.5开始对可变参数的定义提供新支持，相当于变种数组。

```java
//方法可变参数
public static int sum(int ... data) {   //用...代替[]
	int sum = 0;
	for(int i=0;i<data.length;i++) {
		sum += data[i];
	}
	return sum;
}
--------------------------------------------------------
int arr[] = new int[] {1,2,4,5,6};
System.out.println(ArrayUtil.sum(arr));   -> 18
System.out.println(ArrayUtil.sum(1,2,4,5,6));   -> 18
```

最大作用：在以后进行进行程序类设计或者开发者调用时，利用此种形式可以避免数组的传递操作，但其本质仍然是数组。

#### 5.8对象数组

对象数组的定义格式如下：

- 动态初始化：类  对象数组名称  [] = new 类  [长度]

```java
	Person per[] = new Person[3];
	per[0] = new Person("张三",21);
	per[1] = new Person("李四",22);
	per[2] = new Person("王五",23);
	for(Person temp : per) {
		System.out.println(temp.getInfo());
	}
```

- 静态初始化：类  对象数组名称  [] = new 类 []{实例化对象....}

```java
	Person per[] = new Person[] {
			new Person("张三",21),
			new Person("李四",22),
			new Person("王五",23)};
```

对象数组的内存分析：

<img src=".\markdownpicture\面向对象编程_1\image-20211010160535898.png" alt="image-20211010160535898" style="zoom: 80%;" />

​		**所有的开发都离不开对象数组，数组最大缺陷是长度固定，优势是数据线性保存，根据索引访问，速度较快(时间复杂度为1)**

### 六、案例分析

 #### 6.1类关联结构

> 利用面向对象的设计来实现一个人有一辆车，一辆车有一个主人的关系转换

```java
Person类：
private Car car;   //一个人有一辆车
//人与车没有直接关系，可以通过后期方法设置
public void setCar(Car car) {
	this.car = car;
}
public Car getCar() {
	return this.car;
}
---------------------------------------------------
Car类：
private Person per;   //每辆车有一个主人
public void setPerson(Person per) {
		this.per = per;
}
public Person getPerson() {
	return this.per;
}
---------------------------------------------------
//第一步：声明对象并设置彼此的关系
Person person = new Person("凯迪",21);
Car car = new Car("凯迪拉克XT5",300000.0);
person.setCar(car);   //一个人有一辆车
car.setPerson(person);  //一辆车有一个主人
//第二步：根据关系获取数据
System.out.println(person.getCar().getInfo());  //查看人的车信息
System.out.println(car.getPerson().getInfo());  //查看车的主人信息
```

本次操作的两个类型：Person、Car都是自定义类型，但是Person和Car都可以描述一类群体，现在对群体关系做出了设置。

#### 6.2自身关联

> 在Person类中定义children类

```java
private Person [] children;   //一个人有多个孩子
public void setChildren(Person [] chrldren){
    this.children = children;   //对象栈内存指向
}
public Person [] getChilidren(){  //返回对象数组
    return this.children;
} 
------------------------------------------------------------------
Person childA = new Person("jinjin", 22);
Person childB = new Person("kaikai", 21);
person.setChildren(new Person[] {childA,childB});
childA.setCar(new Car("BMW",300000.0));
childB.setCar(new Car("QQ",200000.0));

//根据车找到所有人对应的孩子以及对应的车
for(int i=0; i<person.getChildren().length; i++) {
	System.out.println(person.getChildren()[i].getInfo());
	System.out.println(person.getChildren()[i].getCar().getInfo());
}
```

> 对象数组在开发中能描述**多**这个概念：例如一个公园有多个人，即一个公园类中有人对象数组属性

#### 6.3合成设计模式

> 要求定义一种可以描述电脑组成的类。电脑分为显示器和主机，而主机中包含一系列硬件

```java
class 电脑{
    private 显示器 对象数组[];
    private 主机 对象;
}
class 显示器{};
class 主机{
    private 主板 对象；
    private 鼠标 对象;
    private 键盘 对象；
}
class 主板{
    private 内存 对象数组 [];
    private CPU 对象数组 [];
    private 显卡 对象
}
class 键盘{}
class 鼠标{}
```

​		任何人类的产品可以拆分，而后进行重新组合，所以这样的设计在java中被称为合成设计模式。

拆分出的模块都是独立的，每个模块依靠标准整合。面向对象就是拆开后按标准合在一起。

### 七、综合实战：数据表与简单Java类映射

#### 7.1简单映射关系：

- 数据实体表设计 = 类的定义；
- 表中的字段 = 类的成员属性；
- 表的外键关联 = 引用关联；
- 表的一行记录 = 类的一个实例化对象；
- 表的多行记录 = 对象数组；

<img src=".\markdownpicture\面向对象编程_1\image-20211011144732526.png" alt="image-20211011144732526" style="zoom: 67%;" />

- 一个部门有多个雇员；
- 一个雇员有一个部门；
- 一个部门有一个领导；

代码要求：

- 根据部门信息获得以下内容：
  - 一个部门的完整信息；
  - 一个部门之中所有雇员的完整信息；
  - 一个雇员对应的领导的信息；
- 根据雇员信息获得以下内容：
  - 一个雇员所在的部门信息；
  - 一个雇员对应的领导信息。

**解决步骤：**先抛开所有关联字段不看，写出类的基本组成，而后通过引用配置关联字段的关系。

> 类中配置对象：第一步：写出基本类 ;     第二步：配置关联字段       
>
> 主类中根据结构获取数据：第三步：根据关系进行类定义(实例化对象+关联设置)；第四步：根据关系获取数据

```java
public class Dept {
	private long Dno;
	private String Dname;
	private String loc;
	private Emp emps[];  //一个部门有多个雇员
	
	public void setEmps(Emp[] emps) {
		this.emps = emps;
	}
	public Emp[] getEmps() {
		return this.emps;
	}
	public Dept() {
		this(11111, "未分配", "未分配");
	}
	public Dept(long Dno, String Dname, String loc) {
		this.Dno = Dno;
		this.Dname = Dname;
		this.loc =loc;
	}
	public String getInfo() {
		return "【部门信息】\n部门编号："+this.Dno+"\t部门名称："+this.Dname+"\t部门位置："+this.loc;
	}

}
```

```java
public class Emp {
	private long eno;
	private String ename;
	private String job;
	private double sal;
	private double comm;
	private Dept dept;   //一个雇员有一个部门
	private Emp mgr;     //一个雇员有一个领导
	
	public void setDept(Dept dept) {
		this.dept = dept;
	}
	public void setMgr(Emp mgr) {
		this.mgr = mgr;
	}
	public Dept getDept() {
		return this.dept;
	}
	public Emp getMgr() {
		return this.mgr;
	}
	public Emp() {
		this(0000,"无名氏","未分配",0.0,0.0);
	}
	public Emp(long eno, String ename, String job, double sal, double comm) {
		this.eno = eno;
		this.ename = ename;
		this.job =job;
		this.sal = sal;
		this.comm = comm;
	}
	public String getInfo() {
		return "雇员编号："+this.eno+"\t雇员姓名："+this.ename+"\t雇员职位："+this.job+"\t工资："+this.sal+"\t佣金："+this.comm;
	}

}
```

```java
public class Main {

	public static void main(String[] args) {
		// TODO 自动生成的方法存根
		// 实例化对象
		Dept dept = new Dept(11,"科技部","上海");
		Emp emp_1 = new Emp(1101,"fkd","CEO",60000.0,0.0);
		Emp emp_2 = new Emp(1102,"hwj","Manager",20000,1000.0);
		Emp emp_3 = new Emp(1103,"lyp","clerk",10000,100.0);
		//设置关联信息
		dept.setEmps(new Emp[] {emp_1,emp_2,emp_3});
		emp_1.setDept(dept);emp_1.setMgr(null);
		emp_2.setDept(dept);emp_2.setMgr(emp_1);
		emp_3.setDept(dept);emp_3.setMgr(emp_2);
		//根据结构获取数据
		System.out.println(dept.getInfo());  //获取部门的完整信息
		for(int i=0; i<dept.getEmps().length; i++) {
			System.out.println(dept.getEmps()[i].getInfo());   //一个部门中所有雇员信息
			if(dept.getEmps()[i].getMgr() != null) {
				System.out.println("【老板信息】:\n"+dept.getEmps()[i].getMgr().getInfo());  //雇员对应老板信息
			}
			System.out.println();
		}
		System.out.println("-----------------------------------------------");
		
		System.out.println(emp_2.getDept().getInfo());   //一个雇员所在的部门
		System.out.println(emp_2.getMgr().getInfo());    //一个雇员对应的老板信息
	}
}
```

#### 7.2一对多映射

![image-20211011182105874](.\markdownpicture\面向对象编程_1\image-20211011182105874.png)

- 获取一个分类的完整信息；
- 可以根据分类获取其对应的所有子分类的信息。

```java
private Subitem[] subitems; //一个类对应多个分类
private Item item;  //一个子类归属主类
--------------------------------------------
//实例化对象
Item item = new Item(111,"图书");
Subitem subitems [] = new Subitem[] {
	new Subitem(111_1,"经济类"),
	new Subitem(111_2,"科技类"),
	new Subitem(111_3,"语言类")};
//建立关联对象联系
item.setSubitems(subitems);
for(int i=0; i<subitems.length; i++) {
	subitems[i].setItem(item);
}
//获取数据
System.out.println(item.getInfo());  //主类信息   
for(int i=0; i<item.getSubitems().length; i++) {
	System.out.println(item.getSubitems([i].getInfo());      //主类下的所有子类信息
	}
}
```

#### 7.3多对多映射

![image-20211011182248404](.\markdownpicture\面向对象编程_1\image-20211011182248404.png)

- 获取一个用户访问的所有商品的详细信息；
- 获取一个商品被浏览过的全部用户的信息

> 多对多不考虑访问记录

```java
	private Member members[];
------------------------------
    private Product products[];
------------------------------
    //初始化对象,先单一对象，再建立关系
	Member m1 = new Member(01,"宋浩伟");
	Member m2 = new Member(02,"刘云鹏");
	Member m3 = new Member(03,"郝文杰");
	Product proA = new Product(0001,"Java语言",40.0);
	Product proB = new Product(0002,"数据结构与算法",35.5);
	Product proC = new Product(0003,"计算机网络",50.0);
	m1.setProducts(new Product[] {proA});
	m2.setProducts(new Product[] {proA,proC});
	m3.setProducts(new Product[] {proA,proB,proC});
	proA.setMembers(new Member[] {m1,m2,m3} );
	proB.setMembers(new Member[] {m3});
	proC.setMembers(new Member[] {m2,m3});
	//根据对象获取数据
	System.out.println("-------------------根据人获得商品信息---------------------");
	System.out.println(m3.getInfo());
	for(int i=0; i<m3.getProducts().length;i++) {
		System.out.println("\t["+(i+1)+"]"+m3.getProducts()[i].getInfo());
	}
	System.out.println("--------------------根据商品获得人信息---------------------");
	System.out.println(proC.getInfo());
	for(int i=0; i<proC.getMembers().length;i++) {
		System.out.println("\t["+(i+1)+"]"+proC.getMembers()[i].getInfo());
    }
```

#### 7.4复杂多对多关系(权限管理)

基本关系如下：

- 一个用户可以有多个角色，一个角色可能有多个用户
- 一个角色可以拥有多个权限

![image-20211014154035172](.\markdownpicture\面向对象编程_1\image-20211014154035172.png)

实现功能：

- 可以根据一个用户找到用户对应的所有角色，以及每个角色对应的所有权限信息；
- 可以根据一个角色找到角色下所有权限，以及该角色全部用户信息；
- 可以根据权限找到具备此权限的所有用户信息。

Member类：

```java
public class Member {
	private long mid;
	private String name;
	private Role roles[];   //一个用户有多个角色
	
	public void setRoles(Role[] roles) {
		this.roles = roles;
	}
	public Role[] getRoles() {
		return this.roles;
	}
	
	public Member(long mid,String name) {
		this.mid = mid;
		this.name = name;
	}
	public String getInfo() {
		return "【用户信息】id:"+this.mid+"\tname:"+this.name;
	}
}
```

Role类：

```java
public class Role {
	private long rid;
	private String title;
	private Member members[];   //一个角色对应多个用户
	private Privilege privileges[]; //一个角色对应多个权限
	
	public void setMembers(Member[] members) {
		this.members = members;
	}
	public void setPrivileges(Privilege[] privileges) {
		this.privileges = privileges;
	}
	public Member[] getMembers() {
		return this.members;
	}
	public Privilege[] getPrivileges() {
		return this.privileges;
	}
	public Role(long rid, String title) {
		this.rid = rid;
		this.title = title;
	}
	public String getInfo() {
		return "【角色信息】id:"+this.rid+"\ttitle:"+this.title;
	}
}
```

Privilege类：

```java
public class Privilege {
	private long pid;
	private String title;
	private Role role;
	
	public void setRole(Role role) {
		this.role = role;
	}
	public Role getRole() {
		return this.role;
	}
	
	public Privilege(long pid, String title) {
		this.pid = pid;
		this.title =title;
	}
	public String getInfo() {
		return "【权限信息】id:"+this.pid+"\ttitle:"+this.title;
	}
}
```

Main类：

```java
public class Main {

	public static void main(String[] args) {
		// 实例化对象
		Member Mem1 = new Member(11,"孙克");
		Member Mem2 = new Member(12,"郝文杰");
		Role roleA = new Role(111,"系统设置");
		Role roleB = new Role(112,"人事管理");
		Role roleC = new Role(113,"备份管理");
		Privilege pA1 = new Privilege(1001,"系统重启");Privilege pA2 = new Privilege(1002,"系统修改");
		Privilege pB1 = new Privilege(1011,"增加员工");Privilege pB2 = new Privilege(1012,"员工离职");Privilege pB3 = new Privilege(1013,"员工调岗");
		Privilege pC1 = new Privilege(1021,"系统备份");Privilege pC2 = new Privilege(1022,"日志备份");
		//设置对应的关系
		Mem1.setRoles(new Role[] {roleA,roleC});
		Mem2.setRoles(new Role[] {roleA,roleB,roleC});
		roleA.setMembers(new Member[] {Mem1,Mem2}); roleA.setPrivileges(new Privilege[] {pA1,pA2});
		roleB.setMembers(new Member[]{Mem2}); roleB.setPrivileges(new Privilege[] {pB1,pB2,pB3});
		roleC.setMembers(new Member[] {Mem1,Mem2}); roleC.setPrivileges(new Privilege[] {pC1,pC2});
		pA1.setRole(roleA);pA2.setRole(roleA);
		pB1.setRole(roleB);pB2.setRole(roleB);pB3.setRole(roleB);
		pC1.setRole(roleC);pC2.setRole(roleC);
		//根据结构调用得到最后的结果
		System.out.println("-----------------------------根据用户查询-------------------------------");
		System.out.println(Mem2.getInfo());
		for(int i=0; i<Mem2.getRoles().length; i++ ) {
			System.out.println("["+(i+1)+"]"+Mem2.getRoles()[i].getInfo());
			for(int j=0; j<Mem2.getRoles()[i].getPrivileges().length;j++) {
				System.out.println("\t("+(j+1)+")"+Mem2.getRoles()[i].getPrivileges()[j].getInfo());
			}
		}
		System.out.println("----------------------------根据角色查询---------------------------------");
		System.out.println(roleB.getInfo());
		System.out.println("【权限信息】");
		for(int i=0; i<roleB.getPrivileges().length;i++) {
			System.out.println("["+(i+1)+"]"+roleB.getPrivileges()[i].getInfo());
		}
		System.out.println("【用户信息】");
		for(int i=0; i<roleB.getMembers().length; i++) {
			System.out.println(roleB.getMembers()[i].getInfo());
		}
		System.out.println("---------------------------根据权限查询-----------------------------------");
		System.out.println(pA1.getInfo());
		for(int i=0; i<pA1.getRole().getMembers().length;i++) {
			System.out.println("\t["+(i+1)+"]"+pA1.getRole().getMembers()[i].getInfo());
		}
	}
}
```

### 八、String类

#### 8.1特点分析

1.字符串是java利用JVM的支持制造的一种可以简单使用的String类，包装的是一个数组,并且可以像基本数据类型那样直接赋值处理。

>  java源代码文件：C:\Program Files\Java\jdk1.8.0_221  src.zip-java-lang
>
> - JDK1.8之前String类保存的是字符数组(private final char[] value);
>
> - JDK1.9以后保存的是字节数组(private final byte[] value)

2.String类，并且有两种对象实例化形式：

```java
String strA = "aaa";   //入池
String strB = new String("aaa");    //另外开辟空间
```

- 直接赋值法可以实现数据共享

```java
strA = "aaa";  //指向池中内存
strB = "aaa";
strA == strB ; ----> true  //判断栈内存所存的堆内存地址
```

原因：Java底层提供有“字符串池”(字符串数组)，实现池数据自动保存，有相同数据定义时可以减少对象的产生

- 构造方法实例化开辟两块堆内存空间(“aaa”匿名对象一块，new一块)，并指向new开辟的内存

```java
String str1 = "lazy";  //直接赋值指向池
String str2 = new String("lazy");  //不指向池
System.out.println(str1 == str2);   --->  false
```

手动入池: public String intern()方法

```java
String str = new String("aaa").intern();
```

**面试题：String类两种对象实例化方法区别？**

- 直接赋值：只产生一个实例化对象，并且自动保存入对象池，实现实例的重用
- 构造方法：产生两个实例化对象，不入池不重用，但可以通过intern()方法手动入池

3.字符串的比较(有变形)：public boolean equals(String str);

```java
strA.equals(strB);
```

**面试题：请解释String比较中“==”和equals()的区别？**

- “==”:进行的是数值比较，如果用于对象比较中比较的是两个对象的地址
- equals():是类提供的比较方法，可以直接用于字符串内容的判断

4.任何“xxxxx”定义的字符串常量实际上描述的都是String类的匿名对象

```java
String str = "aaa";
"aaa".equals(str);  //匿名对象能够调用方法
```

​		**对象相等判断小技巧：开发时要求某些数据是用户输入，并且要求为指定内容时，建议将字符串常量写在前面。**

```java
String input = null;//空对象没有指向，无法调用equals()方法
"aaa".equals(input);//而字符串常量是匿名对象，开辟了堆内存，不会出现NullPointerException
```

5.String对象池(常量池)主要目的为了实现数据的共享处理，可分为：

- 静态常量池：程序(*.class)在加载时自动将字符串、常量、类和方法的信息等全部进行分配
- 运行时常量池：程序加载后存在有变量(可修改)

``` java
String info = "kaidi";
String str1 = "fukaidi";
String str2 = "fu"+info;
str1 == str2;        ---->false  //静态常量池与运行时常量池不同，可用.equals()判断
```

6.字符串内容不可修改(字节数组)。（只会新开辟空间，更改指向）

```java
str = "fu";
str += "kaidi";
---------------------
String str = "aa";   //“aa”是匿名对象
str = "bb";          //更改堆内存指向，内容没变
```

![image-20211015200225571](.\markdownpicture\面向对象编程_1\image-20211015200225571.png)

7.Java主方法分析：public static void main(String args[]){}

- public:指的是一种访问权限，是公共的；
- static:主方法是由类直接调用的；程序执行通过类名称 java demo
- void:主方法无返回
- main:系统定义的主方法名称，让系统可找
- String args[]:字符串数组，程序启动参数接收

#### 8.2Javadoc文档

- field summary:成员属性摘要；constructor summary：构造方法摘要(depracated不用)
- 方法摘要:method summary (左边为返回值，右边为方法名称和参数)
- 随时查阅javadoc JDK9([javadoc JDK9]( https://docs.oracle.com/javase/9/docs/api/overview-summary.html)) 

#### 8.3String类常用方法

- 字符串与字符

方法

```java
*public String(char[] value); //将字符数组转为字符串
*public String(char[] value,int offset,int count)//截取
public char charAt(int index);//获取指定索引字符
*public char[] toCharArray(); //将字符串转为字符数组
```

> 将部分小写字符串转为大写输出

```java
String str = "fukaidi";
char[] arr = str.toCharArray();  //字符串转为字符数组
for(int i=0;i<arr.length;i++) {
	arr[i] -= 32;
}
String str1 = new String(arr,2,5);  //字符数组转为字符串
System.out.println(str1);
```

> 做一个验证功能，判断某一个字符串的数据是否全部由数字组成

```java
public static void main(String[] args) {
	String str = "12345a67";
	System.out.println(isNumber(str) ? "check in" : "check out");  //利用三目运算法
}
public static boolean isNumber(String str) {
	char[] arr = str.toCharArray();
	for(int i=0; i<arr.length; i++) {
		if(arr[i]<'0' || arr[i]> '9') {
			return false;
		}
	}
	return true;
}
```

**在实际开发中处理中文往往使用char类型，因为其可包含中文数据**。

- 字符串与字节

> 字符串与字节转换主要目的为了进行二进制数据传输或编码转换

方法：

```java
*public String(byte[] bytes){}; //将字节数组转为字符串
public String(byte[] bytes, int offset, int lengeh){}
*public byte[] getBytes();//将字符串转为字节数组
*public byte[] getBytes(String charsetName)throws UnsupportedEncodingException
//编码转换
```

- 字符串比较

```java
*public boolean equals(String anObject)://区分大小写的比较
public boolean equalsIgnoreCase(String anotherString)://不区分大小写的比较
*public int compareTo(String anotherString);//按字典顺序从头进行字符串大小写比较，当第一位相同时比较第二位，返回int(>0,=0,<0)
public int compareToIgnoreCase(String str);//忽略大小写大小比较
```

- 字符串查找

````java
*public boolean contains(String s);//判断子字符串存在？
*public int indexOf(String str);//从头查找指定字符串位置,无返回时-1
public int lastIndexOf(String str);//从后向前寻找指定字符串位置(索引仍是正序)
public int indexOf(String str,int fromIndex);//从指定位置查找指定字符串位置
public int lastIndexOf(String str,int fromIndex);//从指定位置从后查找指定字符串位置
*public boolean startsWith​(String prefix);//判断是否以指定字符串开头
public boolean startsWith​(String prefix,int toffset);//判断指定位置是否以指定字符串开头
*public boolean endsWith​(String suffix);//判断是否以指定字符串结尾
````

- 字符串替换

```java
public String replaceAll(String regex, String replacement);//替换全部
public String replaceFirst(String regex,String replacement);//替换首个
```

- 字符串拆分

```java
public String[] split(String regex);//按照指定字符串全部拆分
public String[] split(String regex,int limit);//按照指定字符串拆分为指定个数，后面不拆
```

**注意：遇到不能拆分的情况用//转义**

```java
String str = "192.163.1.12";
string[] result = str.split("\\.");
```

- 字符串截取

```java
public String substring​(int beginIndex);//从指定索引截取到结束
public String substring​(int beginIndex,int endIndex);//指定截取范围
```

> 截取文件名中的姓名，字符串结构：用户ID-photo-张三.jpg

```java
String str = "fkdzju-photo-傅凯迪.jpg";
int beginIndex = str.indexOf("-", str.indexOf("photo"))+1;
int endIndex = str.lastIndexOf(".");
System.out.println(str.substring(beginIndex, endIndex));
```

- 格式化字符串

> 类似于C中格式化输出语句，可利用占位符输出：字符串(%s)、字符(%c)、整数(%d)、小数(%f)

```java
String name = "fu"; int age = 21; double score = 98.2342;
String str = String.format("姓名：%s、年龄：%d、成绩：%5.2f",name,age,score);
```

- 其他方法

```java
public String concat​(String str);//字符串连接操作
intern();//字符串入常量池
public boolean isEmpty​();//判断字符串内容为空？""与null前者有对象但为空，后者没对象
public String trim​();//去除左右空格信息
public String toUpperCase​(Locale locale);//转大写，非字母不转
public String toLowerCase​();//转小写
```

**注意区分：字符串有.length()方法，数组有.length属性**

> **定义首字母大写方法**

```java
public class StringUtil {
	public static String initCap(String str) {
		if(str == null || str == "") {  //非空
			return str;
		}else if(str.length() == 1) {   //单字符
			return str.toUpperCase();
		}else {
			return str.substring(0,1).toUpperCase().concat(str.substring(1).toLowerCase());
		}
	}
}
```

### 九、继承与覆写

#### 9.1继承

> 简单java类虽然可以解决结构性问题，但相关类间代码有大量重复，要实现重用，使用继承。
>
> 所谓继承的本质：在已有类的功能上继续进行功能的扩充

1.实现：**class 子类 extends 父类{}**:

> 子类又称为派生类，父类又称为超类(SuperClass)，子类可以定义更多的功能并且描述的范围更小，子类能够操作父类的属性

2.子类对象实例化流程：在进行子类对象实例化的时候一定要首先实例化好父类对象

原因：在进行子类实例化的时候，会由系统自动默认调用父类的无参构造方法（实例化父类对象）

- super()：如果父类中没有提供无参构造，这时必须利用super()明确调用父类有参构造（调用父类构造方法）

> 结论：无论如何，在实例化子类对象的同时一定会实例化父类对象，目的是为了所有的属性可以进行空间分配
>
> - super与this都可以调用构造方法，super是由子类调用父类的构造，而this是调用本类的构造，并且都要放在构造方法的首行，所以两个语句不允许同时出现

3.继承的相关限制

- Java中不允许多重继承，只允许多层继承(不超过三层)。   主要目的是为了继承多个类中的方法。

```java
class A{}
class B extends A{}
class C extends B{}
```

- 在进行继承关系定义时，子类可以继承父类所有操作(继承代码)，但私有操作属于隐式继承，非私有操作属于显示继承。

```java
public class Student extends Person{
	private String school;
	public Student(String name, int age, String school) {
		super(name,age);   //明确父类构造,没声明时调用super()父类无参
		this.school = school;
	}
	public void fun() {
		//System.out.println(name); //直接访问不可,私有
		System.out.println(getName());//可以间接访问
	}
}
```

#### 9.2覆写

> 子类可以保留父类的方法或者属性的名称进行覆写

1.方法覆写

> 当子类与父类方法名称，参数类型、个数一模一样时称为方法覆写，覆写的意义在于优化父类的功能。
>
> 在子类进行覆写后，如果子类仍然想要继续调用父类中的方法，用super.方法()

```java
class Channel{
	public void connect() {
		System.out.println("资源连接成功");
	}
}
class DatabaseChannel extends Channel{
	public void connect() {   //覆写方法
		super.connect();   //覆写后仍然调用父类方法
		System.out.println("数据库连接成功");
	}
}
public class Maindemo {

	public static void main(String[] args) {
		new DatabaseChannel().connect();		
	}
}
```

方法覆写限制：

- 被覆写的方法不能拥有更严格的访问权限。(public > default >  private(仅对本类可见))。如果父类用的是default，那么子类只能用public 或者default；父类用public，子类只能用public

- 父类方法用private定义时，不存在覆写不覆写，因为对子类不可见。

>  实际开发时95%方法都用public，因此覆写用public

**面试题：请解释Overloading与Override的区别？Overloading时返回参数是否相同？**

- 中文含义：重载  VS  覆写
- 概念：方法名称相同，参数的类型及个数不同      VS       方法名称、参数类型及个数均相同
- 权限：没有权限限制    VS     被覆写的方法不能拥有更严格的权限
- 范围：发生在同一个类中    VS     发生在继承关系中

在进行方法重载时没对返回值类型做出限制，但一致时更方便处理

2.属性覆盖

> 子类定义了与父类名称相同的成员。属性一旦封装private属性覆盖将没有意义,因为属性对外部不可见

**面试题：请解释super与this的区别？**

- this表示从本类中查找所需要的属性或方法，如果本类不存在则查找父类定义;super表示不查找子类，直接查找父类
- this和super都可以进行构造方法的调用，this()调用的是本类构造，而super()是由子类调用父类构造，两个语句都必须放在构造方法的首行，不能同时出现。
- this可以表示当前对象。this.name

#### 9.3final关键字

> final在程序描述中是种终结器的概念，功能如下：**定义不能被继承的类**，**不能被覆写的方法**，**常量**

```java
final class Channel{}//不能再有子类了
public final void connect(){}//方法不能被覆写
public static final int ON = 1;//定义常量高电平
public static final OFF = 0;//定义常量低电平
```

​		常量都是公共的定义，往往使用public static final来定义全局常量(公共的、共享的、不可改变的)

- 在方法的时候用final定义参数，也表示常量的概念

```java
final String str = "fu";  //定义常量
String str1 = "fukaidi";
String str2 = str+"kaidi";
System.out.println(str1 == str2);  ->true  //此时都入常量池
```

#### 9.4继承综合案例

一、建立一个人类(Person)和学生类(Student)，功能要求如下：

![image-20211016183429831](.\markdownpicture\面向对象编程_1\image-20211016183429831.png)

```java
public class Person {
	private String name;
	private String addr;
	private char sex;
	private int age;
	public Person() {}
	public Person(String name, String addr) {
		this(name,addr,'男',18);
	}
	public Person(String name, String addr, char sex, int age) {
		this.name = name;
		this.addr = addr;
		this.sex = sex;
		this.age = age;
	}
	public String getInfo() {
		return "姓名:"+this.name+"\t地址:"+this.addr+"\t性别:"+this.sex+"\t年龄:"+this.age;
	}
}
```

```java
public class Student extends Person{
	private double math;
	private double eglish;
	public Student() {}
	public Student(String name,String addr) {
		super(name,addr);
	}
	public Student(String name,String addr,char sex,int age,double math,double eglish) {
		super(name,addr,sex,age);
		this.math = math;
		this.eglish = eglish;
	}
	public String getInfo() {
		return super.getInfo()+"\t数学成绩:"+this.math+"\t英语成绩:"+this.eglish;
	}
}
```

二、定义员工类，具有姓名、年龄、性别属性，并具有构造方法和显示数据方法。定义管理层类继承员工类，并有自己的属性职务和年薪。定义职员类，继承员工类，并有自己的属性所属部门和月薪。

```java
public class Employee {
	private String name;
	private int age;
	private String sex;
	public Employee() {}
	public Employee(String name, int age, String sex) {
		this.name = name;
		this.age = age;
		this.sex = sex;
	}
	public String getInfo() {
		return "姓名："+this.name+"\t年龄："+this.age+"\t性别："+this.sex;
	}
}
```

```java
public class Manager extends Employee {
	private String job;
	private double income;
	public Manager() {}
	public Manager(String name, int age, String sex, String job, double income) {
		super(name, age, sex);
		this.job = job;
		this.income = income;
	}
	public String getInfo() {
		return "【管理层】:"+super.getInfo()+"\t职务："+this.job+"\t年薪："+this.income;
	}
}
```

```java
public class Clerk extends Employee{
	private String dept;
	private double salary;
	public Clerk() {}
	public Clerk(String name, int age, String sex, String dept, double salary) {
		super(name,age,sex);
		this.dept = dept;
		this.salary = salary;
	}
	public String getInfo() {
		return "【职员信息】："+super.getInfo()+"\t部门："+this.dept+"\t月薪"+this.salary;
	}
}

```

三、编写程序，统计出字符串“want you to know one thing”中字母n和字母o的出现次数

机构化设计：

```java
public class StringUtil {
	private String content;
	public StringUtil(String content) {
		this.content = content;
	}
	public String getContent() {
		return this.content;
	}
	public String getInfo() {
		return this.content;
	}
}
```

```java
public class StringCount extends StringUtil{//父类主要传递字符串信息
	private int ncount;
	private int ocount;
	public StringCount(String content) {
		super(content);   //父类没有无参构造，需特指super构造
		Count();      //在实例化对象时执行方法
	}
	public int getNcount() {
		return ncount;
	}
	public int getOcount() {
		return ocount;
	}
	public void Count() {
		char[] data = super.getContent().toCharArray();//转换为字符数组
		for(int i=0; i<data.length; i++) {
			if(data[i] =='o') {
				ocount++;
			}
			if(data[i] == 'n') {
				ncount++;
			}
		}
	}
	public String getInfo() {
		return "【统计信息】：字母n的个数是："+this.ncount+"、字母o的个数是："+this.ocount;
	}
}
```

```java
String str = "want you to know one thing";
StringCount sc = new StringCount(str);
System.out.println(sc.getInfo());
```

四、建立一个可以实现整型数组的操作类，而后在里面可以操作数组的大小由外部来决定，在类中要提供有数组的如下处理：数据的增加、可以实现容量的动态扩充以及取得全部数组内容。再派生出两个子类：数组排序类与数组反转类



**父类的方法和设计往往都很重要，如果功能相同的时候子类应该以覆写父类的方法为优先考虑**

```java
public class Array {
	private int[] data;
	private int foot;   //脚标控制
	public Array(int length) {
		if(length > 0) {
			this.data = new int[length];    //开辟动态数组
		}else {
			this.data = new int[1];
		}
		
	}
	public boolean add(int num) {  //添加数据
		if(foot < data.length) {
			data[foot++] = num;   
			return true;
		}
		return false;
	}
	public void increacement(int addlength) { //容量扩充
		int[] temp = new int[data.length+addlength];
		System.arraycopy(data, 0, temp, 0, data.length);
		this.data = temp; //更换指向
	}
	public int[] getData() {
		return this.data;
	}
}
```

```java
public class ArraySort extends Array{
	public ArraySort(int length) {
		super(length);
	}
	public int[] getData() {   //覆写方法
		Arrays.sort(super.getData());//属性通过包装不可视，要通过getter
		return super.getData();
	}
}
```

```java
public class ArrayReverse extends Array{
	public ArrayReverse(int length) {
		super(length);
	}
	public int[] getData() {
		int center = super.getData().length/2;//交换次数
		int head = 0;
		int foot = super.getData().length-1;
		for(int i=0;i<center;i++) {
			int temp = super.getData()[head];//前后交换
			super.getData()[head] = super.getData()[foot];
			super.getData()[foot] = temp;
			head++;
			foot--;
		}
		return super.getData();
	}
}
```

```java
public class Maindemo {
	public static void main(String[] args) {
		ArrayReverse arr = new ArrayReverse(3);
		System.out.println(arr.add(1));
		System.out.println(arr.add(3));
		System.out.println(arr.add(6));
		arr.increacement(1);
		System.out.println(arr.add(2));
		for(int temp:arr.getData()) {
			System.out.print(temp+" ");
		}
	}
}
```

### 十、Annotation注解

> 作用：减少程序配置代码，并进行结构化的定义，以注解的形式实现程序开发

**服务器资源包括：地址、端口、用户名密码**

<img src=".\markdownpicture\面向对象编程_1\image-20211018183917324.png" alt="image-20211018183917324" style="zoom:80%;" />

过程一：引入配置文件，在配置文件中定义全部要使用的服务器

过程二：将配置信息重新写回到程序里面，利用特殊标注与程序代码分离。(Annotation)

- 实际开发：Annotation+配置文件

JAVA中基本注解：

#### 10.1准确的覆写：@Override

> 在明确覆写的方法上追加注解，方便编译时检查错误。

```java
@Override     //写在方法上方，明确覆写
public int[] getData() {   //覆写方法	
	Arrays.sort(super.getData());
}
```

#### 10.2过期声明：@Deprecated

> 软件迭代开发过程中，老版本某个类或者方法在新版本有不适应的地方，采用过期声明，告诉新用户不要再用了。
>
> 可以柔和的实现代码的过渡。

```java
@Deprecated     //写在方法上方，声明过期
public boolean add(int num) {}
```

> 使用该方法时会警告它是老版本了，但运行不会出错

#### 10.3压制警告：@SuppressWarnings

> 不愿意见到提示信息，可以进行警告信息的压制处理，只是为了让警告信息不出现。

### 十一、多态性

> 多态性是在继承性的基础上拓展出来的概念，可以实现父子类的互相转换处理。

- 方法的多态性：
  - 方法的重载：同一个方法名称可以根据传入参数的类型和各数的不同实现不同功能；
  - 方法的覆写：同一个方法根据子类的不同有不同的实现。
- 对象的多态性：父子实例的转换处理
  - 对象向上实例：父类 父类实例 = 子类实例、自动完成          90%    (人是个动物)
  - 对象向下转型：子类 子类实例 = （子类） 父类实例、强制转换(子类对父类功能扩充)

#### 11.1对象向上转型

> 自动完成的原因是：此时对象既属于父类也属于子类。(看new之后的类型，前面只是父类帽子)
>
> 特点：**将参数声明成父类类型，可以在运行时传入任何子类对象。**可以对参数可以进行统一设计，实现接受或返回参数的统一性。

```java
public class Main {

	public static void main(String[] args) {
		fun(new DatabaseMessage()); //Message msg = new DataBaseMessage()
		fun(new WebserverMessage());//Messsge msg = new WebserverMessage()
        //指明DatabaseMessage类和WebserverMessage类从属Message类
	}
    public void fun(Message msg){//不管传递哪个子类都能用一个参数接收,自动
        msg.print();
    }
}
class Message{
	public void print() {
		System.out.println("数据连接中...");
	}
}
class DataMessage extends Message{
	@Override
	public void print() {
		System.out.println("数据库连接中...");
	}
}
class WebserverMessage extends Message{
    @Override
    public voide print(){
        System.out.println("Web服务器连接中...");
    }
}
```

#### 11.2对象向下转型

> 主要特点在于需要使用到一些子类自己特殊的定义处理

```java
Person per = new SuperMan(); //向上转型   父类实例per除子类覆写外只能用父类方法
per.print();
SuperMan man = (SuperMan) per; //向下转型  子类实例man可用父类与子类方法
man.fire();
man.print();
```

向上描述的是公共特征，而向下描述的是子类自己特殊的定义环境。

​		**向下转型有安全隐患：向下转型前必须先向上转型**，两个没有任何关系的实例发生强制转换(父类不知子类)，会出现“ClassCastException”的异常

```java
Person per = new Person();    //不转型
SuperMan man = (SuperMan) per;   //“ClassCastException”的异常,因为父类实例不是子类的对象，不能转换
```

- instanceof关键字:判断某个实例是否是某个类的对象      对象  instanceof  类(返回boolean)

开发时，在进行转型前先判断是否能进行转型

```java
if(per instanceof SuperMan){
	SuperMan man = (SuperMan)per;
    man.fly();
}
```

#### 11.3Object类

> Object类不存在有继承关系，Object类是所有类的父类，可以接受所有数据类型，解决参数统一问题。
>
> Object类是一个万能的数据类型，它更加适合于进行程序的标准设计（万能参数入口，可以进入任何类）

- 可以利用Object类接受引用数据类型：包括类、数组、接口

```java
class Person{}    ==    class Person extends Object
```

- 获取对象信息：toString()

> 在Java中默认对象输出时调用的方法就是toString()方法,获得编码
>
> 在开发中对象信息的获得可以覆写此方法来替代getInfo

```java
@Override
public String toString(){
    return "姓名："+this.name+"、年龄："+this.age;
}
```

- 对象比较：equals()，public boolean equals(Object obj)

```java
public boolean equals(Object obj) {   //java源代码
    return (this == obj);  //进行的是地址比较
}
```

要进行对象内容比较需要覆写equals()方法，例如String类

```java
public boolean equals(object obj){ 
    if(!(obj instance of Person)){//！为取反
        return false;  //传入对象非Person类
    }
    if(obj == null){
        return false;  //避免出现空指向问题
    }
    if(this == obj){  //同一个地址(一个地址只能指向一块内容)
        return true;
    }
    //传进普通类时，已经进行了向上传递。 Object obj = new Person();
    //父类没法获取子属性信息，需要进行向下转型
    Person per = (Person) obj;  //目的获取类中属性
    return this.name.equals(per.name)&&this.age == per.age;//在类内部 
}
```

#### 11.4抽象类

> 在实际开发中，很少会继承已经完善的类，而是继承抽象类。因此**父类**设计时优先考虑抽象类。-------在普通类基础上追加抽象方法
>
> 抽象类的主要作用在于**对子类中覆写方法进行约定**，在抽象类中用抽象方法(用关键字abstract定义且没有提供方法体的方法)。

```java
abstract class Message{
    private String type;
    public abstract String getConnnectInfo();//抽象方法
    public String getType(){
        return this.type;
    }
    public void setType(String type){
        this.type = type;
    }
}
```

- 抽象类不是完整的类必须提供子类；
- 抽象类的子类不是抽象类，一定要覆写抽象类的所有方法；
- 抽象类的对象实例化可以利用对象多态性通过子类向上转型方式完成。

```java
abstract class Message{  //抽象类的定义
	private String type;
  	public Message() {
		System.out.println("Message构造方法");
	}
	public abstract String getConnectInfo();  //抽象方法
	public String getType(){
		return this.type;
	}
	public void setType(String type) { //普通方法
		this.type = type;
	}
}
class DatabaseMessage extends Message{
	public DataBaseMessage{
        super();
    }
    @Override
	public String getConnectInfo() {
		return "数据库连接成功";
	}
}
public class Main {
	public static void main(String[] args) {
		Message msg = new DatabaseMessage(); //用向上转型的方式实现抽象对象的实例化
		System.out.println(msg.getConnectInfo());
		msg.setType("lol");
		System.out.println(msg.getType());
	}
}
```

**关于使用的几点意见与说明：**

- 抽象类只是对子类有了抽象方法的强制覆写约束而已，其他与普通类相同；
- 抽象类尽管可以没有抽象方法,但抽象类自身仍无法用new实例化，必须依靠子类完成；
- 抽象类主要目的是进行过渡操作使用，所以当使用抽象类进行开发时主要是为了解决继承问题带来的代码重复处理；
- 抽象类可以提供有构造方法，并且子类会按照对象实例化原则进行父类对象调用；
- 抽象类中可以提供有static方法，不受抽象类限制，永远可以通过类名称直接调用方法。

```java
abstract class Message{  //抽象类的定义
	public static String getMessage() {
		return "ok";
	}
}
class DatabaseMessage extends Message{
}
public class Main {
	public static void main(String[] args) {
		System.out.println(Message.getMessage());
	}
}
```

**模板设计模式：**

- 定义抽象父类：对所有行为进行统一规范处理，相当于提供操作模板；
- 抽象类最大的好处一是对子类方法的统一管理，二是可以自身提供有一些普通方法可以调用抽象方法(这些抽象方法必须在子类提供实现的时候才会生效)

```java
abstract class Action{  //抽象类的定义
	public static final int EAT=1;//常量
	public static final int SLEEP=5;
	public static final int WORK=10;
	public void command(int code) {
		switch(code) {//操作行为
		case EAT:{
			this.eat();
			break;
		}
		case SLEEP:{
			this.sleep();
			break;
		}
		case WORK:{
			this.work();
			break;
		}		
		}
	}
	//定义三种行为种类
	public abstract void eat();   
	public abstract void sleep();
	public abstract void work();
}
class People extends Action{
	public void eat() {
		System.out.println("人吃饭");
	}
	public void sleep() {
		System.out.println("人睡觉");
	}
	public void work() {
		System.out.println("人工作");
	}
	
}
class Robert extends Action{
	public void eat() {
		System.out.println("给机器人充电");
	}
	public void sleep() {}
	public void work() {
		System.out.println("机器人工作");
	}
}
public class Main {
	public static void main(String[] args) {
		Action peopleaction = new People();
		Action robertaction = new Robert();
		peopleaction.command(Action.EAT);  //static属性直接调用
		peopleaction.command(Action.SLEEP);
		peopleaction.command(Action.WORK);
		robertaction.command(Action.EAT);
		robertaction.command(Action.SLEEP);
		robertaction.command(Action.WORK);
	}
}
```

#### 11.5包装类

> 将基本数据类型以类的形式进行包装,处理后可以像对象一样进行引用传递，同时也可以使用Object类进行接收

```java
class Int{
	private int data;  //包装了一个基本数据类型int
	public Int(int data) {
		this.data = data;
	}
	public int intValue() {
		return this.data;
	}
}
public class Maindemo {
	public static void main(String args[]) {
		Object obj = new Int(3); //装箱：将基本数据类型保存在包装类之中(构造方法定义)
		int x = ((Int) obj).intValue();//拆箱：从包装类中获取基本数据类型	
		System.out.println(x*2);
	}
}
```

![image-20211020101033538](.\markdownpicture\面向对象编程_1\image-20211020101033538.png)

- 对象型的包装类(Object的直接子类)：Boolean,Character
- 数值型的包装类(Numeber直接子类)：Int,Byte,Long,Short,Float,Double

Number是一个抽象类，表示的是一个数字的概念，定义有如下方法：

```java
public byte byteValue​();       //从包装类获取byte数据
public short shortValue​();     //从包装类中获取short数据
public abstract int intValue​();//从包装类中获取int数据
public abstract long longValue​(); //从包装类中获取long数据
public abstract float floatValue​();//从包装类中获取float数据
public abstract double doubleValue​();//从包装类中获取double数据
```

**装箱与拆箱操作：**

- 数据装箱：将基本数据类型保存到包装类之中，一般可以用构造方法完成

```java
Integer类:public Integer(int value);
Double类：public Double(double value);
Boolean类：public Boolean(boolean value);
```

- 数据拆箱：从包装类中获取基本数据类型：
  - 数值型包装类已经由Number类定义了拆箱的方法;
  - boolean类：public boolean booleanValue()；

> 以int和Integer为例：

```java
Integer obj = new Integer(3);  //装箱
int x = obj.intValue();  //拆箱
System.out.println(x);
```

> 以double与Double为例

```java
Double obj = new Double(10.1);  //装箱
double x = obj.doubleValue();  //拆箱
System.out.println(x);
```

> 以boolean与Boolean为例

```java
Boolean obj = new Boolean(true);  //装箱
boolean x = obj.booleanValue();  //拆箱
System.out.println(x);
```

**重要：JDK1.5之后提供了自动的装箱与拆箱操作（int到Integer;double到Double）。**

```java
Integer obj = 5; //自动装箱，此时不需要考虑构造方法
int x = obj;   //自动拆箱
obj++;   //包装类对象可以直接参与数学运算
System.out.println(obj);
```

**使用自动装箱的最大好处是可以实现Object接受基本数据类型**

范例：object接受小数：

```java
Object obj = 19.2; //doule自动装箱为Double,并自动向上转型为Object
double num = (Double)obj;  //向下转型为Double类，再自动拆箱
```

- 使用包装类进行相等判断的时候一定要用equals()方法完成

### 十二、接口

#### 12.1接口的定义

> ​		抽象类与普通类相比最大的优势在于可以实现对子类覆写方法的控制，但抽象类中的普通方法里面可能仍会涉及一些安全或者隐私的操作问题。如果想在开发中对外部隐藏所有的实现细节，可以通过接口来描述。
>
> ​		接口可以理解为一个严格的抽象类(最原始的定义接口之中只包含有**抽象方法与全局常量**，自JDK1.8之后引入了Lambda表达式后，接口还可以定义普通方法与静态方法。

范例：定义一个接口

```java
interface IMessage{  //命名与类相同，前加I
    public static final String INFO = "fukaidi"; //全局常量
    public abstract String getInfo(); //抽象方法
}
```

对接口的使用，原则如下:

- 接口需要被子类实现(implements)，一个子类可以实现多个父接口；
- 子类一定要覆写接口中的全部抽象方法；
- 接口对象可以利用子类对象的向上转型进行实例化。USB usb = new Keyboard()；
- Java中使用接口主要目的是：一个子类可以实现多个接口，相当于多继承的概念。
- 接口中抽象方法的访问权限都为public，所以写与不写一样，覆写时只能使用public访问权限。此外接口类可以省略abstract。

```java
interface IMessage{
	(public static final) String INFO = "fkd";
	(public abstract) String getInfo();
}
interface IChannel{
	public abstract boolean connect();
}
abstract class DatabaseImple{
	public abstract boolean getDatabaseConnect();
}
class MessageImple extends DatabaseImple implements IMessage,IChannel{//实现多接口
	public String getInfo() {
		if(this.connect()) {
			return "实现了接口";
		}
		return "建立失败";
	}
    public boolean connect(){
		System.out.println("消息通道建立成功...");
		return true;
	}
    public boolean getDatabaseConnect() {
		System.out.println("数据库连接成功");
		return true;
	}
}
public class Maindemo {
	public static void main(String args[]) {
		IMessage msg = new MessageImple();  //向上转型
		System.out.println(msg.getInfo());
		System.out.println(IMessage.INFO);//直接调用静态常量
	}
}
```

<img src=".\markdownpicture\面向对象编程_1\image-20211020163156209.png" alt="image-20211020163156209" style="zoom: 67%;" />

​		此时MessageImple实现了IMessage和IChannel两个接口，所以子类可以是这两个接口任意一个实例，这两个接口实例可以转换。

```java
IMessage msg = new MessageImple();
System.out.println(msg instanceof IChannel);//true
IChannel chl = (IChannel) msg;  //实现转换
```

**Object与接口转换**

```java
IMessage msg = new MessageImpl();
Object obj = msg; //向上转型
IChannel chan = (IChannel) obj; //(同一个子类) 
System.out.println(chan.connect());
```

**总结：Object类对象可以接受所有数据类型，包括基本数据类型、类对象、接口对象、数组。**

- **在实际开发过程中，一个接口可以继承多个接口，一个抽象类可以实现多个接口，而一个普通类只能继承一个抽象类并且可以实现多个父接口，但是要求先继承后实现**

```java
class MessageImple extends DatabaseImple implements IMessage,IChannel{}
```

- 接口无法继承父类，但可以通过extends继承若干个父接口，称为接口的多继承。

```java
//extends在类继承上只能继承一个父类，但是接口可以多继承
interface IService extends IMessage,IChannel{}
```

在实际开发中，接口的使用往往有三种形式：

- 进行标准设置；
- 表示一种操作能力；
- 暴露远程方法视图，这个一般在RPC分布式开发中使用

#### 12.2接口定义加强

> 解决接口功能扩充：不会让子类直接实现接口，而是中间追加一个过渡的抽象类

<img src=".\markdownpicture\面向对象编程_1\image-20211020193634052.png" alt="image-20211020193634052" style="zoom:80%;" />

所以从JDK1.8之后开始，为了解决接口设计的缺陷，允许开发者在接口中定义普通方法。并用**default**关键字声明。------------该方案作为挽救方案，一般设计时还是定义过渡抽象类

```java
interface IMessage{
	public String getMessage();
	public default boolean connect(){//追加的普通方法
		System.out.println("建立了连接");
		return true;
	}
    public static IMessage getInstance() {//定义的静态方法
		return new MessageImple();//获得一个子类对象(匿名)
	} 
}
class MessageImple implements IMessage{
	public String getMessage(){//抽象方法需要覆写
		if(this.connect()) {
			return "成功咯";
		}
        return "没有消息";
	}
}
public class Maindemo {
	public static void main(String args[]) {
		IMessage msg = new MessageImple();
		System.out.println(IMessage.getInstance().connect());
	}
}
```

- 接口中除普通方法外，还可以定义static方法通过接口直接调用。此时接口所具备的功能完全可以取代抽象类了。但是设计时应该奉行：**接口就是抽象方法**。

#### 12.3使用接口定义标准

> 不同类之间通过接口关联，现实中的标准无处不在如食物接口、交通工具接口等。

<img src=".\markdownpicture\面向对象编程_1\image-20211021091644726.png" alt="image-20211021091644726" style="zoom:80%;" />

```java
interface IUSB{
	public boolean check();//检查标准
	public void work();//工作
}
class Computer{
	public Computer() {
		//定义构造方法
	}
	public void plugin(IUSB usb) {//参数接口标准(可以传入所有子类)
		if(usb.check()) {
			usb.work();
		}else {
			System.out.println("接口不符合标准");
		}
	}
}
class print implements IUSB{
	public boolean check() {
		return true;
	}
	public void work() {
		System.out.println("打印机正常工作");
	}
}
class keyboard implements IUSB{
	public boolean check() {
		return false;
	}
	public void work() {
		System.out.println("键盘正常工作");
	}
}
public class Maindemo {
	public static void main(String args[]) {
		Computer cmp = new Computer();//使用类前先产生对象
		cmp.plugin(new print());//利用向上转型
		cmp.plugin(new keyboard());
	}
}
```

#### 12.4工厂设计模式(Factory)

> 在客户端(主方法)new实体对象会带来耦合问题，而造成耦合的直接元凶：“关键字new”。以JVM设计为例，Java实现可移植性的关键在于：JVM利用虚拟机运行JAVA程序，与操作系统无关，由JVM来进行匹配，因此良好的设计应该避免耦合。

- 客户端程序类与IFood接口的子类没有任何关联，所有的关联都是通过Factory类完成的，程序运行时可以通过初始化参数来进行子类的定义。(子类对客户端隐藏)
- 程序维护新增子类时只需要在factory中新增定义对象

![image-20211021105541427](.\markdownpicture\面向对象编程_1\image-20211021105541427.png)

```java
interface IFood{//定义一种食物标准
	public void eat();
}
class Bread implements IFood{//面包实现类
	public void eat() {
		System.out.println("吃面包");
	}
}
class Milk implements IFood{//工厂实现类
	public void eat() {
		System.out.println("喝牛奶");
	}
}
class Factory {//在Factory类中实例化对象
	public static IFood getInstance(String classname) {
		if("bread".equalsIgnoreCase(classname)) {
			return new Bread();
		}else if("milk".equalsIgnoreCase(classname)){
			return new Milk();
		}else {
			return null;
		}
	}
}
public class Maindemo {
	public static void main(String args[]) {
		IFood food = Factory.getInstance("MilK");
		food.eat();
	}
}
```

#### 12.5代理设计模式(Proxy)

> 代理设计模式的主要功能是帮助用户将所有开发的注意力只集中在核心业务功能处理上。

<img src=".\markdownpicture\面向对象编程_1\image-20211023185540405.png" alt="image-20211023185540405" style="zoom:80%;" />

```java
interface IEat{
	public void get();
}
class Eatman implements IEat{//核心业务
	public void get() {
		System.out.println("好好享受美食。");
	}
}
class EatProxy implements IEat{//代理主题负责准备和收尾业务
	private IEat eat;//将核心业务保留为类属性
	public EatProxy(IEat eat) {//初始化时传入核心业务
		this.eat = eat;
	}
	public void prepare() {
		System.out.println("1.准备食材、烹饪");
	}
	public void clean() {
		System.out.println("3.收拾食材");
	}
	public void get() {//在覆写业务时加入代理业务
		this.prepare();
		this.eat.get();//获取核心业务
		this.clean();
	}
}
public class Maindemo {
	public static void main(String args[]) {
		IEat eat = new EatProxy(new Eatman());//通过代理操作真实业务
		eat.get();
	}
}
```

代理设计模式的特点是：一个接口提供有两个子类，其中一个是真实业务操作类，另外一个主题是代理业务操作类。

#### 12.6抽象类与接口的区别

| No   | 区别       | 抽象类                                                       | 接口类                                       |
| ---- | ---------- | ------------------------------------------------------------ | -------------------------------------------- |
| 1    | 定义关键字 | abstract class 抽象类名称{}                                  | interface 接口类名称{}                       |
| 2    | 组成       | 全局常量、成员属性、构造方法、普通方法、抽象方法、static方法 | 全局常量、抽象方法、普通方法、statcic方法    |
| 3    | 权限       | 任意方法                                                     | 只能用public                                 |
| 4    | 子类使用   | 子类通过extends关键字可以继承一个抽象类                      | 子类通过implements可以实现多个接口           |
| 5    | 关系       | 抽象类可以实现多个接口                                       | 接口不允许继承抽象类，但是允许继承多个父接口 |
| 6    | 使用       | 1.抽象类或接口必须定义子类；2.子类一定要覆写抽象类或接口中的全部抽象方法 | 3.通过子类向上转型实现抽象类或接口实例化     |

<img src=".\markdownpicture\面向对象编程_1\image-20211024161208528.png" alt="image-20211024161208528" style="zoom: 67%;" />

​		接口与抽象类是最初的设计，是Java中最核心的概念，也是所有设计模式的综合体现。接口可以避免单继承的局限。

#### 12.7接口与抽象类应用

> 1.考虑一个表示绘图的标准，并且可以根据不同的图形来进行绘制

 <img src=".\markdownpicture\面向对象编程_1\image-20211024162857712.png" alt="image-20211024162857710" style="zoom: 80%;" />

```java
interface IGraphical{//定义绘画标准
	public void paint();
}
class Point{//定义一个点
	private double x;
	private double y;
	public Point(double x,double y) {
		this.x = x;
		this.y = y;
	}
	public double getX() {
		return this.x;
	}
	public double getY() {
		return this.y;
	}
}
class Triangle implements IGraphical{
	private Point[] a;//第一条边(用点数组来描述)
	private Point[] b;//第二条边
	private Point[] c;//第三条边
	public Triangle(Point[] a,Point[] b,Point[] c) {
		this.a = a;
		this.b = b;
		this.c = c;
	}
	public void paint() {
		System.out.println("【第一条边】起始点：("+a[0].getX()+","+a[0].getY()+")\t终点：("+a[1].getX()+","+a[1].getY()+")");
		System.out.println("【第二条边】起始点：("+b[0].getX()+","+b[0].getY()+")\t终点：("+b[1].getX()+","+b[1].getY()+")");
		System.out.println("【第三条边】起始点：("+c[0].getX()+","+c[0].getY()+")\t终点：("+c[1].getX()+","+c[1].getY()+")");
	}
	
}
class Circular implements IGraphical{
	private double radius;
	public Circular(double radius) {//构造方法相当于要求所提供的数据
		this.radius = radius;
	}
	public void paint() {
		System.out.println("以半径为"+this.radius+"绘制了一个圆");
	}
}
class Factory{//隐藏实现子类
	public static IGraphical getInstance(String classname,double ...args) {//传入定义可变参数数组，用...代替[]
		if("Triangle".equalsIgnoreCase(classname)) {
			return new Triangle(//先实例化点数组，再实例化点
					new Point[] {new Point(args[0],args[1]),new Point(args[2],args[3])},
					new Point[] {new Point(args[4],args[5]),new Point(args[6],args[7])},
					new Point[] {new Point(args[8],args[9]),new Point(args[10],args[11])}
			);
		}else if("Circular".equalsIgnoreCase(classname)) {
			return new Circular(args[0]);
		}else {
			return null;
		}		
	}
}
public class Maindemo {
	public static void main(String args[]) {
		IGraphical igp = Factory.getInstance("Circular", 3.0);
		igp.paint();
		IGraphical igc = Factory.getInstance("Triangle", 1,1,3,1,3,1,2,2,2,2,1,1);
		igc.paint();
	}
}
```

> 定义类Shape，用来表示一般二维图形。Shape具有抽象方法area和perimeter,分别用来计算面积和周长，定义二维形状类(如矩形、三角形、圆形、椭圆形)，这些类均为Shape类的子类。

```java
abstract class Shape{
	public abstract double getArea();
	public abstract double getPerimeter();
}
class Circular extends Shape{
	private double radius;
	public Circular(double radius) {
		this.radius = radius;//将传入的数据存入属性
	}
	public double getArea() {
		return 3.141592*radius*radius;
	}
	public double getPerimeter() {
		return 2*3.141592*radius;
	}
	
}
class Square extends Shape{
	private double length;
	private double width;
	public Square(double length,double width) {
		this.length = length;
		this.width = width;
	}
	public double getArea() {
		return this.length*this.width;
	}
	public double getPerimeter() {
		return 2*(this.length+this.width);
	}
}
class Factory{
	public static Shape getInstance(String classname,double ... args) {//传入可变参数，定义为可变参数数组
		if("Circular".equalsIgnoreCase(classname)) {
			return new Circular(args[0]);
		}else if("Square".equalsIgnoreCase(classname)) {
			return new Square(args[0],args[1]);
		}else {
			return null;
		}
	}
}
public class JavaDemo {
	public static void main(String[] args) {
		Shape sp = Factory.getInstance("square", 1,2);
		System.out.println("【矩形】面积："+sp.getArea()+"\t周长："+sp.getPerimeter());
		Shape sp1 = Factory.getInstance("Circular",1);
		System.out.println("【圆形】面积："+sp1.getArea()+"\t周长："+sp1.getPerimeter());
	}
}
```

使用工厂设计模式完全隐藏了实现的子类。

### 十三、泛型

#### 13.1泛型定义

> 泛型问题引入：java希望通过泛型解决ClassCastException的问题，部分解决向下转型的安全隐患。

存储任意数据类型的X与Y:（利用Object）

```java
class Pointa{//存储任意数据类型的X与Y
	private Object x;
	private Object y;
	public Pointa(Object x,Object y) {
		this.x = x;
		this.y = y;
	}
	public void setX(Object x) {
		this.x = x;
	}
	public Object getX() {
		return this.x;
	}
	public void setY(Object y) {
		this.y = y;
	}
	public Object getY() {
		return this.y;
	}
}
public class Main {
	public static void main(String[] args) {
		Pointa point = new Pointa(10.1,"aa");//自动装箱+向上转型
		double x =(Double)point.getX();//强制向下转型后，自动拆箱
		double y =(Double)point.getY();
		System.out.println("x:"+x+"\ty:"+y);
	}
}
```

​		Object能传入任何数据类型，存在有安全隐患。为避免出现“‘ClassCastException”最好的做法是回避对象的强制转换。

**泛型的本质：类中的属性或方法的参数与返回值的类型可以由对象实例化(使用者)的时候动态决定，即由外部决定**

- 那么此时需要在类定义的时候明确的定义占位符(泛型标记)

```java
class Pointa<T>{//T是Type缩写，泛指多个类型
	private T x;
	private T y;
	public Pointa(T x,T y) {
		this.x = x;
		this.y = y;
	}
	public void setX(T x) {
		this.x = x;
	}
	public T getX() {
		return this.x;
	}
	public void setY(T y) {
		this.y = y;
	}
	public T getY() {
		return this.y;
	}
}
public class Main {
	public static void main(String[] args) {
		Pointa<Double> point = new Pointa<Double>(10.1,11.1);//只局限于此对象为Double
		double x = point.getX();//自动拆箱
		double y = point.getY();
		System.out.println("x:"+x+"\ty:"+y);
	}
}
```

- 提示：不设置泛型类型时，默认的泛型类型是Object类，但会出现警告。

**泛型使用的注意点：**

- 泛型之中只允许设置引用类型，**如果要操作基本类型必须使用包装类(Integer,Double,String)**
- 从JDK1.7开始可以简化为Pointa<Double> point = new Pointa<>(10.1,11.1);

#### 13.2泛型通配符

> 在引用传递时方法中采用<?>通配符的处理可以接受所有数据类型，且不允许修改，只允许取值

```java
class Message<T>{
	private T content;
	public T getContent() {
		return this.content;
	}
	public void setContent(T content) {
		this.content = content;
	}
}
public class Main {
	public static void main(String[] args) {
		Message<String> msg = new Message<>();
		msg.setContent("fukaidi");
		fun(msg);
	}
	public static void fun(Message<?> msg) {//当不确定类型时用？
		//msg.setContent("aa");//错误，设置通配符后无法设置参数
		System.out.println(msg.getContent());
	}
}
```

在"?"这个通配符基础上还提供两类小的通配符：(设置泛型上下限)

- ?extends类：设置泛型的上限；
  - 例如：定义“？extends Number”：表示该泛型只允许设置Number或Number的子类
- ?super类：设置泛型的下限;
  - 例如："? super String":只能够使用String或其父类

```java
class Message<T extends Number>{}//设置上限
public static void fun(Message<? super Integer> temp)//设置下限
```

#### 13.3泛型接口

泛型除了在类中定义外，可以在接口中进行使用：

```java
interface IMessage<T>{}
```

对于泛型接口的子类而言有两种实现方式

- 在子类中继续进行泛型定义

```java
interface IMessage<T>{
	public String getMessage(T t);
	public void fun();
}
//继续定义泛型
class IMessageImpl<S> implements IMessage<S>{
	public String getMessage(S s) {
		return "【Message】:"+s;
	}
	public void fun() {//普通抽象方法
		System.out.println("fkd");
	}
}
public class Main {
	public static void main(String[] args) {
		IMessage<Integer> isg = new IMessageImpl<Integer>();
		System.out.println(isg.getMessage(1));
		isg.fun();
	}
}
```

- 在子类实现父接口时直接定义出具体泛型

```java
class IMessageImpl implements IMessage<String>{}
IMessage<String> isg = new IMessageImpl();
```

#### 13.4泛型方法

> 泛型方法不一定非要出现在泛型类之中，泛型数据类型用<T>T来定义

```java
public class Main {
	public static void main(String[] args) {
		Integer[] num = fun(1,2,3);//泛型只能使用包装类或引用数据类型
		for (int temp:num) {
			System.out.println(temp);
		}
	}
	//返回传入任意类型的数组
	public static <T>T[] fun(T ... args){
		return args;
	}
}
```

举例：传统工厂模式中一个接口的取得就需要编写一个工厂类或者多接口时一个工厂类中有许多重复的方法。

修改后的工厂设计模式：(13.7)

> 只需将方法返回值类型定义为泛型<T> T,在返回值时强制转换为接口类<T> T

```java
class Factory{
	@SuppressWarnings("unchecked")
	public static <T> T getInstance(String classname,double ... args) {//传入可变参数，定义为可变参数数组
		if("Circular".equalsIgnoreCase(classname)) {
			return (T) new Circular(args[0]);
		}else if("Square".equalsIgnoreCase(classname)) {
			return (T) new Square(args[0],args[1]);
		}else if("Triangle".equalsIgnoreCase(classname)) {
			return (T) new Triangle(//先实例化点数组，再实例化点
					new Point[] {new Point(args[0],args[1]),new Point(args[2],args[3])},
					new Point[] {new Point(args[4],args[5]),new Point(args[6],args[7])},
					new Point[] {new Point(args[8],args[9]),new Point(args[10],args[11])}
			);
		}else {
			return null;
		}
	}
}

public class JavaDemo {
	public static void main(String[] args) {
		Shape sp = Factory.getInstance("square", 1,2);
		System.out.println("【矩形】面积："+sp.getArea()+"\t周长："+sp.getPerimeter());
		Shape sp1 = Factory.getInstance("Circular",1);
		System.out.println("【圆形】面积："+sp1.getArea()+"\t周长："+sp1.getPerimeter());
		IGraphical igc = Factory.getInstance("Triangle", 1,1,3,1,3,1,2,2,2,2,1,1);
		igc.paint();
	}
}
```

### 十四、包的定义及使用

> 包名称小写，不同包中可以有重复的类，以后类表示：包.类名称

**自动打包编译运行(DOS):**

- java文件中定义package
- 在文件夹中运行cmd>   javac -d . Hellojava.java(-d表示生成package目录结构；"."表示在所在目录中生成程序类文件)
- 运行时在根包目录下cmd> java zju.edu.cn.Hellojava

**包导入：**

- import 包.类名称  ：导入类

  > public class对其他包开放，类名称与*.java名称一致，一个java文件只能一个public class；class只能被本包访问，不能被外包调用

- **import zju.edu.cn. * **导入包中所需要的类，为避免同名歧义，完整实例化类名称

```java
import object.*;
object.Emp emp = new object.Emp();
```

> 开发过程中往往会定义重名类名称，但包名称不重名，为了更好解决问题，有时候可以使用完整类名称

**静态导入：(很少用)**

> 全部由静态方法提供的特殊类可以采用静态导入处理形式（相当于该方法定义在主类中）

```java
package zju.sdu.test;

import static zju.edu.MathUtil.*;//传统方法：import zju.edu.MathUtil

public class TestMain {

	public static void main(String[] args) {
		System.out.println(add(1,2,3,4));//原始为MathUtil.add(1,2,3,4)
		System.out.println(sub(2, 1));
	}
}
```

**生成jar文件：**

> 压缩结构jar文件：用于聚合大量的Java类文件、相关的[元数据](https://baike.baidu.com/item/元数据)和资源（文本、图片等）文件到一个文件

- 对程序打包编译：javac -d . Hellojava.java（生成目录zju.edu.cn下,Hellojava.class文件）
- 将其打包为my.jar
  - ”-c“:创建一个新的jar文件；
  - “-v”得到一个详细输出；
  - “-f”设置要生成de jar文件名称

```DOS
D:\VS>jar -cvf my.jar zju
```

- 每一个*.jar都是一个独立的程序路径，在java程序中使用此路径必须通过CLASSPATH配置,之后便可以编译和执行

```Dos
SET CLASSPATH=.;D:\VS\my.jar
javac -d . Test.java
jaca zju.edu.cn.Test
```

#### 14.1Eclipse导出和导入jar文件

> 不同项目间包调用

- 导出：选择包—>右键导出jar文件
- 调用jar:在项目中新建lib文件夹，放入要导入的jar包—>右键项目—>构建路径—>库—>添加jar

**JDK1.9后将原来rt.jar模块化，原来在JVM运行时会加载所有类库(几十M)，现在会自动选择加载对应模块**



#### 14.2系统常见包

- Java自身提供的类库(除了JDK提供的类库外还有一些标准)
- 由第三方厂商提供的Java支持类库，可以完成各种所需要的功能，并且支持厂商很多

而在JDK中也会提供有大量的类库，并且这些类库都是封装在不同的开发包之中的：

- java.lang:String、Number、Object等类
- java.lang.reflect:反射机制处理包，所有设计从此开始
- java.util：工具类的定义，包括数据结构的定义
- java.io:输入与输出流操作的程序包
- java.net:网络程序开发的程序包
- java.sql:进行数据库编程的开发包
- java.applet:Java最原始的使用形式，现在的程序以Application为主(有主方法的程序)
- java.awt、javax.swing:Java中图形化界面开发(GUI)

#### 14.3访问控制权限

实现封装性主要依靠的是访问控制权限，访问权限定义有四种：private、default(不写)、protected、public(属性，方法)

| NO   | 访问范围         | private | default | protected    | public |
| ---- | ---------------- | ------- | ------- | ------------ | ------ |
| 1    | 同一包中的同一类 | √       | √       | √            | √      |
| 2    | 同一包中的不同类 |         | √       | √            | √      |
| 3    | 不同包的子类     |         |         | √(super调用) | √      |
| 4    | 不同包的所有类   |         |         |              | √      |

说明protected访问权限：

```java
package startlearn_1;
public class Message {
	protected void info() {
		System.out.println("发送信息成功");
	}
}

package startlearn_2;
import startlearn_1.Message;
public class NetMessage extends Message{
	public void print() {
		super.info();
	}
}

// Message父类与NetMessage子类不同包
// 通过父类访问info方法，×
Message msg1 = new NetMessage();
msg1.info();
//通过子类访问父类的protected属性，√
NetMessage msg2 = new NetMessage();
msg2.print();
```

**参考的选择方案：**(90%)

- 只要属性定义，全部使用private;
- 只要是方法的定义，全部使用publc;

### 十五、UML图形

#### 15.1类图

> 图形化形式实现程序类关系的描述。描述类：类名称+属性+方法三层

- 属性：“访问权限 属性名称：属性类型”的格式定义。访问权限public(+),protected(#),private(-)
- 方法：“访问权限 方法名称()：返回值”来描述。

工具：PowerDesigner,先编写程序，后导出UML图(FILE——reverse Engineer——Object languange)

![image-20211028192520967](.\markdownpicture\面向对象编程_1\image-20211028192520967.png)

#### 15.2时序图

> 描述代码执行流程

![image-20211028193307516](.\markdownpicture\面向对象编程_1\image-20211028193307516.png)

#### 15.3用例图

> 描述的是程序的执行分配

![image-20211028194340330](.\markdownpicture\面向对象编程_1\image-20211028194340330.png)

一般出现在项目的设计过程中比较多

### 十六、单例设计模式

> 是一种控制实例化对象产生个数的设计操作

#### 16.1单例设计

> 只能进行一次实例化对象，例如操作系统调用系统数据类(在程序运行中将一直存在的实例化对象，并且不会改变，内容是动态加载的)

- 饿汉式单例设计：实例化对象为属性，定义static方法返回

```java
class Singleton{
	//将实例化对象定义在内部，并描述为公共的final常量
	private static final Singleton ST = new Singleton(); 
	private Singleton() {}//构造方法私有化,类外部不可视
	public void info() {
		System.out.println("fkd,go,go,go!");
	}
	public static Singleton getInstance() {
		return ST;
	}
}
public class TestMain {
	public static void main(String[] args) {
		Singleton st = null;//声明对象
		st = Singleton.getInstance();
		st.info();
	}
}
```

- 懒汉式单例设计：在static方法中实例化对象

```java
class Singleton{
	private static Singleton st; 
	private Singleton() {}//构造方法私有化,类外部不可视
	public void info() {
		System.out.println("fkd,go,go,go!");
	}
	public static Singleton getInstance() {
		if(st == null) {//第一次使用
			st = new Singleton();//实例化对象
		}
		return st;
	}
}
public class TestMain {
	public static void main(String[] args) {
		Singleton st = null;//声明对象
		st = Singleton.getInstance();
		st.info();
	}
}
```

**面试题：请编写一个Singleton程序，并说明其主要特点？**

- 代码如上；
- 特点：构造方法私有化，类内部提供有static方法获取实例化对象，不管外部如何操作，类内部永远只提供一个实例化对象

#### 16.2多例设计

> 保留有多个实例化对象，例如描述性别类，对象只有男/女

```java
class Color{
	private static final Color GREEN = new Color("绿色");
	private static final Color RED = new Color("红色");
	private static final Color BLUE = new Color("蓝色");
	private String title;
	private Color(String title) {
		this.title = title;
	}
	public String toString() {
		return this.title;
	}
	public static Color getInstance(String color) {
		switch(color){
		case "red":
			return RED;//有return不用加break
		case "blue":
			return BLUE;
		case "green":
			return GREEN;
		default:
			return null;//有返回值的要包含所有情况
		}
	}
}

public class TestMain {
	public static void main(String[] args) {
		Color cl = Color.getInstance("green");
		System.out.println(cl);
	}
}
```

多例和单例本质相同，在内部提供static方法，提供实例化对象

### 十七、枚举

> 主要作用是定义有限个数对象的一种结构(多例设计)，枚举就属于多例设计，能在编译时报错。

> 本质：相当于一个类，默认继承Enum类

定义一个枚举：

```java
enum Color{
	RED,GREEN,BLUE;//枚举对象
}
public class TestMain {
	public static void main(String[] args) {
		Color c = Color.BLUE;
		System.out.println(c);
		for(Color co:Color.values()) {//values()方法获取所有对象
			System.out.println(co);
		}
	}
}
```

- 利用switch进行枚举项的判断

```java
Color c = Color.BLUE;
switch(c) {//支持枚举
case RED:
	System.out.println("红色");break;
case BLUE:
	System.out.println("蓝色");break;
case GREEN:
	System.out.println("绿色");break;
}
```

#### 17.1Enum类

```java
//构造方法
protected Enum​(String name,int ordinal)
//普通方法
public final String name​()//获得对象名字
public final int ordinal​()//获得对象序号(定义顺序)
```

**面试题：请解释enum与Enum的区别？**

- enum:是从JDK1.5之后提供的一个关键字，用于定义枚举类；
- Enum:是一个抽象类，所有使用enum关键字定义的类默认继承此类

#### 17.2定义枚举类型

> 枚举类型中可以定义构造方法(私有化,非public)、普通方法、属性等。除此之外，枚举还能实现接口。
>
> 此外，枚举类中可以直接定义抽象方法，并且要求每一个枚举对象都覆写该方法。(少用)

```java
interface IMessage{
	public String getMessage();
}
enum Color implements IMessage{
	RED("红色"),GREEN("绿色"),BLUE("蓝色");//枚举对象
	private String title;
	private Color(String title) {
		this.title = title;
	}
	public String getMessage() {
		return this.title;
	}
}

public class TestMain {
	public static void main(String[] args) {
		IMessage msg = Color.BLUE;
		System.out.println(msg.getMessage());
	}
}
```

定义一个Person类，定义性别。

```java
enum Sex{
	MALE("男"),FEMALE("女");
	private String title;
	private Sex(String title) {
		this.title = title;
	}
	public String toString() {//改写输出对象时为String
		return this.title;
	}
}
class Person{
	private String name;
	private int age;
	private Sex sex;
	public Person(String name,int age, Sex sex) {
		this.name = name;
		this.age = age;
		this.sex = sex;
	}
	public String toString() {
		return "姓名："+this.name+"\t年龄："+this.age+"\t性别："+this.sex;
	}
}

public class TestMain {
	public static void main(String[] args) {
		System.out.println(new Person("fkd",22,Sex.MALE));
	}
}
```

### 十八、异常的捕获及处理

> 为了保证出现了非致命的程序错误后，程序依然可以正常完成，所以就需要有一个完善的异常处理机制，以保证程序的正确执行

#### 18.1处理异常

> 用try,catch,finally关键字

```java
try{
    //可能出现异常的语句
}[catch(异常类型 异常对象){
	//异常处理
}catch(异常类型 异常对象){
	//异常处理
}...][finally{
    //不管异常是否处理都要执行;
}]
```

在此格式之中可以使用的组合为try...catch、try ...catch...finally、try ... finally

```java
public class TestMain {
	public static void main(String[] args) {
		System.out.println("1.start");
		try {//无异常时正常输出，有异常时执行
			System.out.println("2.10/0="+(10/0));
		}catch(ArithmeticException e) {//异常类型与异常对象
			e.printStackTrace();//输出异常完整信息
		}finally {//有无异常都执行
			System.out.println("不管是否处理异常，都执行");
		}
		System.out.println("3.end");//有未处理异常时不输出
	}
}
```

- **处理多个异常**

> 即便有了异常处理语句，但是如果没有进行正确的异常捕获，也会导致程序中断（finally代码依然执行）

```java
public static void main(String[] args) {
	System.out.println("1.start");
	try {//无异常时正常输出，有异常时执行
		int x = Integer.parseInt(args[0]);
		int y = Integer.parseInt(args[1]);
		System.out.println("2.10/0="+(x/y));
	}catch(ArithmeticException e) {//被除数为0异常
		e.printStackTrace();
	}catch(NumberFormatException e) {//输入不是数字异常
		e.printStackTrace();//
	}catch(ArrayIndexOutOfBoundsException e) {//没有定义输入异常
		e.printStackTrace();
	}finally {//有无异常都执行
	System.out.println("不管是否处理异常，都执行");
	}
	System.out.println("3.end");
}
```

![image-20211029131941414](.\markdownpicture\面向对象编程_1\image-20211029131941414.png)

1.在程序执行中产生异常将自动进行指定类型的异常类对象实例化处理

2.如果此时程序中没有提供有异常处理的支持，则会采用JVM默认异常处理方式(打印异常信息并中断退出)

3.有异常处理时，此实例化对象会被try捕获

4.try捕获到的异常与catch中的异常进行依次匹配

5.不管异常是否处理，都将执行finally语句。之后进一步判断异常是否处理，没有处理交个JVM，处理了则继续执行代码



**程序可以处理异常的最大类型是Throwable，其有两个子类：**

- Error:程序未执行时出现错误，开发者无法处理；
- Exception:程序中出现的异常，开发者处理

> 由于Exception是所有异常的父类，根据向上转型(用父类接受所有子类)。因此可以简化异常处理。但由于其处理所有异常，因而不便于调试。

```java
try {//无异常时正常输出，有异常时执行
	int x = Integer.parseInt(args[0]);
	int y = Integer.parseInt(args[1]);
	System.out.println("2.10/0="+(x/y));
}catch(Exception e) {//被除数为0异常
	e.printStackTrace();//所有异常向上转型
}
```

​		**在进行多个异常同时处理的时候要把捕获范围大的异常放在捕获范围小的异常之后。**

#### 18.2Throws与Throw关键字

- Throws关键字

> 定义方法时使用throws关键字来进行异常类型的标注，强制告诉被调用处进行捕获处理

```java
class MyMath{
	public static int div(int x,int y)throws Exception {
		return x/y;
	}
}
public class TestMain {
	public static void main(String[] args) {
		try {
			System.out.println(MyMath.div(10, 0));
		} catch (Exception e) {
			e.printStackTrace();
		}	
	}
}
```

主方法可以继续向上抛出异常交给JVM,此时不处理异常:

```java
public static void main(String[] args) throws Exception
```

- Throw关键字

> 手工进行异常的抛出

```java
try {
	throw new Exception("xxx");//异常对象不是由系统生成的，而是由手工定义的
}catch(Exception e) {
	e.printStackTrace();
}
System.out.println("sss");
```

**面试题：解释throw与throws的区别？**

- throw:在代码块中使用，主要是手工进行异常对象的抛出；
- throws:是在方法定义上使用的，表示将此方法处可能产生的异常告诉调用处，让调用处处理

#### 18.3异常处理模型

要求定义一个可以实现除法计算的方法，开发要求如下：

- 在进行数学计算开始与结束时进行信息提示；
- 如果在进行计算的过程中产生了异常，则交给调用处来处理

```java
class MyMath{
	public static int div(int x,int y)throws Exception {
		int temp = 0;
		System.out.println("计算开始");
		try {
			temp = x/y;//出现异常时抛出，不执行后面语句，需要定义finally
		}catch(Exception e){
			throw e;//向上抛异常对象(此部分可略，也会按方法抛给调用层)
		}finally {
			System.out.println("计算结束");
		}
		return temp;
	}
}
public class TestMain {
	public static void main(String[] args){
		try {
			System.out.println(MyMath.div(10, 0));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

在以后实际开发过程中，尤其与处理资源访问结合，尤为重要。

**RuntimeException：**

> 考虑到代码编写方便，对于使用throws定义的方法不用都要求开发者手工处理，提供有一个灵活的可选的异常处理父类“RuntimeException”。这个类的子类不需要强制性处理。

例如：ArithmeticException与NumberFormatException

**面试题：请解释RuntimeException与Exception的区别？**

- RuntimeException是Exception的子类；
- RuntimeException标注的异常可以不需要进行强制性处理，而Exception异常必须强制性处理
- 常见的RuntimeException：ArithmeticException与NumberFormatException、ClassCastException、NullPointerException

#### 18.4自定义异常类

有两种实现方法，继承Exception或者继承RuntimeException

```java
class BombException extends RuntimeException{
	public BombException(String msg) {
		super(msg);//调用父类构造方法，定义错误原因
	}
}
class food{
	public static void eat(int time) throws BombException {
		if(time > 4) {
			throw new BombException("肚子爆炸");
		}else {
			System.out.println("好好吃饭");
		}
	}
}
public class TestMain {
	public static void main(String[] args) {
		food.eat(5);//不用处理
	}
}

```

项目开发过程有大量自定义异常处理，可以通过搜索引擎查找原因

#### 18.5assert关键字

> 确定代码执行到某行后一定是所期待的结果，断言不一定是准确的，也有可能出现偏差，但这种偏差不应该影响程序的正常执行

```java
public static void main(String[] args) {
	int x = 10;
	assert x==100 :"x的内容不是100";  //判断x是否等于100，后面为报错时提供的输出
	System.out.println(x);
}
```

要想执行断言，必须在DOS命令下执行程序时加入参数：

```DOS
java -ea JavaDemo
```

**断言只是一种检测手段，特殊情况下开启**

### 十九、内部类

> 在类内部可以继续定义类，内部类可以使用外部类属性，外部类使用内部类方法要实例化。可以在任意结构中进行定义
>
> 内部类的优势：轻松访问外部类中的私有属性

#### 19.1基本概念

```java
class Outer{//外部类
	private String title = "fkdgo";//定义私有属性
	public void fun() {//普通方法
		Inner in = new Inner();//实例化内部类对象
		in.print();//调用内部类方法
	}
	class Inner{//内部类
		public void print() {
			System.out.println(Outer.this.title);//内部类访问外部类的私有属性
		}
	}
}
public class TestMain {
	public static void main(String[] args) {
		Outer out = new Outer();
		out.fun();
	}
}
```

不使用内部类的方法来实现私有属性的外部调用

```java
//实现私有属性外部调用
class Outer{//外部类
	private String title = "fkdgo";
	public void fun() {
		//步骤三：接受传入的参数对象
		Inner in = new Inner(this);
		in.print();
	}
	//步骤一：提供getter()
	public String getTitle() {
		return this.title;
	}
}
class Inner{//内部类
	//步骤二：接受Outer对象
	private Outer out;
	public Inner(Outer out) {
		this.out = out;
	}
	public void print() {
		System.out.println(out.getTitle());
	}
}
public class TestMain {
	public static void main(String[] args) {
		Outer out = new Outer();
		out.fun();
	}
}
```

**相关说明：**

- 内部类访问外部类的私有属性；外部类访问内部类的私有属性（避免getter与setter）

```java
Outer.this.title;//内部访问外部
new Inner().info;//外部访问内部
```

- 实例化内部类对象(内部类非private)

```java
外部类.内部类 内部类对象 = new 外部类().new 内部类();
```

> 内部类编译完成形成“Outer$Inner.class”类文件，内部类全称即内部类.外部类

- Inner只允许Outer类来使用，不允许外部实例化。则可以用private进行私有定义

```java
class Outer{
    public void fun{
        Inner in = new Inner();
        in.info;
    }
    private class Inner{
        private String info = "fkd";
    }
}
```

#### 19.2内部类接口、抽象类

- 内部接口

```java
interface IChannel{
	public void send(IMessage msg);
	interface IMessage{
		public String getContent();
	}
}
class IChannelImpl implements IChannel{
	public void send(IMessage msg) {//向上转型
		System.out.println(msg.getContent());
	}
	class IMessageImpl implements IMessage{
		public String getContent() {
			return "fkdgogogo";
		}
	}
}
public class TestMain {
	public static void main(String[] args) {
		IChannel cha = new IChannelImpl();
		cha.send(new IChannelImpl().new IMessageImpl());//实例化内部类对象
	}
}
```

- 内部抽象类

```java
interface IChannel{
	public void send();
	abstract class AbstractMessage{
		public abstract String getContent();
	}
}
class IChannelImpl implements IChannel{
	public void send() {
		AbstractMessage amsg = new IMessageImpl();//抽象类实例化用子类
		System.out.println(amsg.getContent());
	}
	class IMessageImpl extends AbstractMessage{
		public String getContent() {
			return "fkdgogogo";
		}
	}
}
public class TestMain {
	public static void main(String[] args) {
		IChannel channel = new IChannelImpl();
		channel.send(); 
	}
}
```

- 接口内部进行接口实现（内部实例化）

```java
interface IChannel{
	public void send();
	class IChannelImpl implements IChannel{
		public void send() {
			System.out.println("fkd");
		}
	}
	public static IChannel getInstance() {
		return new IChannelImpl();
	}
}

public class TestMain {
	public static void main(String[] args) {
		IChannel channel = IChannel.getInstance();
		channel.send(); 
	}
}
```

内部类十分灵活，只要语法满足都可以。

#### 19.3static定义内部类、接口

> static定义内部类相当于“外部类”,只能访问外部类中的static属性或方法(static定义的类和方法只能访问static成员)
>
> 看到类名称有点的都是内部类

```java
//实例化static内部类对象
外部类.内部类 内部类对象 = new 外部类.内部类();
```

```java
class Outer{
	private static final String MSG = "fkd";
	static class Inner{
		public void print() {
			System.out.println(Outer.MSG);
		}
	}
}
public class TestMain {
	public static void main(String[] args) {
		Outer.Inner in = new Outer.Inner();
		in.print();
	}
}
```

- static定义内部接口

> 之所以定义内部接口，主要是因为这些操作属于一组相关的定义，有了外部接口后可以更加清楚描述出这些接口的主要功能

```java
interface IMessageWrap{//消息包装
	static interface IMessage{//消息获取
		public String getContent();
	}
	static interface IChannel{//消息连接
		public boolean getConnect();
	}
	public static void send(IMessage msg,IChannel channel) {//接口类可以直接定义static方法
		if(channel.getConnect()) {
			System.out.println(msg.getContent());
		}else {
			System.out.println("消息发送失败");
		}
	}
}
class DefaultMessage implements IMessageWrap.IMessage{//实现的是内部接口
	public String getContent() {
		return "fkdgogogo";
	}
}
class channelImpl implements IMessageWrap.IChannel{
	public boolean getConnect() {
		return true;
	}
}
public class TestMain {
	public static void main(String[] args) {
		IMessageWrap.send(new DefaultMessage(), new channelImpl());
	}
}
```

#### 19.4 方法中定义内部类

> 内部类可以直接访问外部类中的私有属性，也可以直接访问方法中的参数

```java
class Outer{
	private String message = "love";
	public void fun((final)int num) {
	    (final) String name = "fkd";
		class Inner{
			public void print() {
				System.out.println(Outer.this.message);
				System.out.println(num);
				System.out.println(name);
			}
		}
		new Inner().print();
	}
}
public class TestMain {
	public static void main(String[] args) {
		new Outer().fun(3);
	}
}
```

#### 19.5匿名内部类

> 是一种简化处理形式，主要在抽象类和接口子类上使用

当接口实现只使用一次时，单独定义一个类很浪费，不需要定义子类（可用匿名内部类代替子类）

```java
interface IMessage{
	public void print(String str);
	public static IMessage getInstacne() {//把接口实现方式写在接口里面
		return new IMessage() {//匿名内部类
			public void print(String str) {
				System.out.println(str);
		}
	};
}
}
public class TestMain {
	public static void main(String[] args) {
		IMessage.getInstacne().print("fkd");
	}
}
```

### 二十、函数式编程

#### 20.1Lamda表达式

> 避免复杂面向对象结构的处理形式，简化代码。
>
> 实现要求：SAM(Single Abstract Method)接口或类只有单一抽象方法,这也是为什么JDK1.8之后接口提供有default、static方法的原因。
>
> 目的是替换SAM结构化的形式直接实例化接口

```java
@FunctionalInterface  //函数式接口注解
interface IMessage{
	public void print(String str);
}
public class TestMain {
	public static void main(String[] args) {
//		IMessage msg = new IMessage() {//匿名内部类
//			public void print(String str) {
//				System.out.println(str);
//			}
//		};
        //Lamda表达式
		IMessage msg = (str)->{
            System.out.println(str);
        }
    		msg.print("fkd");
	}
}
```

具体格式：

- 方法没有参数：()->{};
- 方法有参数：(参数，参数)->{};
- 如果只有一行返回语句：(参数，参数)->语句;

```java
interface IMath{
	public int add(int a, int b);
}
public class TestMain {
	public static void main(String[] args) {
		IMath math = (x,y)->  x+y;
		System.out.println(math.add(1,2));
	}
}
```

#### 20.2 方法引用

> 不同的方法名称可以描述统一个方法，抄方法(换皮)
>
> 利用方法引用这一概念可以为一个方法定义多个名字，但是必须是函数式接口

- 引用静态方法：类名称::static方法名称;(如：String的valueOf方法)

```java
@FunctionalInterface
interface IFunction<P,R>{//P为参数，R为返回类型
	public R change(P p);
	}
public class TestMain {
	public static void main(String[] args) {
		IFunction<Integer,String> fun = String::valueOf;//指定泛型接口抄写方法主体
		//等价于String类的valueof()静态方法
//	 System.out.println(String.valueOf(100).length());
		String str = fun.change(100);
		System.out.println(str.length());
	}
}
```

- 引用某个实例对象的方法：实例化对象::普通方法（String的toUpperCase方法）————指出特定对象（相当于顺带实例化了）

```java
@FunctionalInterface
interface IFunction<R>{//R为返回类型
	public R upper();
	}
public class TestMain {
	public static void main(String[] args) {
		IFunction<String> fun = "fkd"::toUpperCase;
		System.out.println(fun.upper());
	}
}
```

- 引用特定类型的方法：特定类::普通方法————没指出对象(特殊情况)

```java
@FunctionalInterface
interface IFunction<P,R>{//P为返回类型
	public P compare(R r1,R r2);
	}
public class TestMain {
	public static void main(String[] args) {
		IFunction<Integer,String> fun = String::compareTo;
		System.out.println(fun.compare("A","a"));
	}
}
```

- 引用构造方法:类名称::new

```java
class Person{
	private String name;
	private int age;
	public Person(String name,int age) {
		this.name = name;
		this.age = age;
	}
	public String toString() {
		return "【姓名】:"+this.name+"、【年龄】:"+this.age;
	}
}
@FunctionalInterface
interface IFunction{
	public Person create(String name,int age);
	}
public class TestMain {
	public static void main(String[] args) {
		IFunction fun = Person :: new;
		System.out.println(fun.create("kfd",22));
	}
}
```

#### 20.3系统包中函数式接口

> 引用JDK中的函数式接口(开发包中java.util.function中)

- 功能型函数式接口
  - String类中有一个方法判断是否以指定的字符串开头:statswith

```java
接口定义：接受并返回值
@FunctionalInterface
public interface Function<T,R>{
    public R apply(T t); 
}
```

```java
接口使用：
import java.util.function.Function;

public class TestMain {
	public static void main(String[] args) {
		Function<String,Boolean> fun = "**asada"::startsWith;//抄普通方法
		System.out.println(fun.apply("**"));
	}
}
```

- 消费型函数式接口，只有输入参数，没有返回
  - Systerm.out.println()

```java
接口定义：接受值
@FunctionalInterface
public interface Consumer<T>{
    public void accept(T t); 
}
```

接口使用：

```java
import java.util.function.Consumer;

public class TestMain {
	public static void main(String[] args) {
		Consumer<String> con = System.out::println;
		con.accept("fkd");
	}
}
```

- 供给型函数式接口：没接收参数，有返回

```java
接口定义：返回值
@FunctionalInterface
public interface Supplier<R>{
    public R get(); 
}
```

接口使用：

```java
import java.util.function.Supplier;

public class TestMain {
	public static void main(String[] args) {
		Supplier<String> sup = "ADAkad"::toLowerCase;
		System.out.println(sup.get());
	}
}
```

- 断言型函数式接口：进行函数判断(可用功能型写)

```java
@FunctionalInterface
public interface<T>{
	public boolean test(T t);
}
```

接口使用：

```java
import java.util.function.Predicate;

public class TestMain {
	public static void main(String[] args) {
		Predicate<String> pre = "asa"::equalsIgnoreCase;//抄普通方法
		System.out.println(pre.test("ASa"));
	}
}
```

### 二十一、链表

> 链表的本质是动态的对象数组，利用引用的逻辑关系实现类似数组的数据处理操作。
>
> 数组的缺陷在于长度固定，依赖索引控制。

![image-20211105213025989](.\markdownpicture\面向对象编程_1\image-20211105213025989.png)

**嵌套操作可用递归完成**

客户端不可能直接操控节点，客户端关心的数据的增删改查。应该包装处理

![image-20211105214148442](.\markdownpicture\面向对象编程_1\image-20211105214148442.png)

**单向链表的基础功能实现：**

- 数据保存

> Link类包装数据,定义有头节点。Node保存有数据和下一节点位置，通过Node内部类处理数据

- 集合个数统计

> 定义获取数据长度的方法size()，在类中定义统计属性count，在每次执行完add()方法后，count++

- 空集合判断

> 判断root==null或者count==0

- 返回集合数据

> 集合的数据一般以对象数组的形式返回

![image-20211106132934521](.\markdownpicture\面向对象编程_1\image-20211106132934521.png)

- 获取指定索引的数据

> 数组获取数据的时间复杂度为1，链表获取数据的时间复杂度为n

![image-20211106144443537](.\markdownpicture\面向对象编程_1\image-20211106144443537.png)

- 修改指定索引的数据

> 同时间复杂度为n

- 判断指定数据是否存在

> 通过对象比较,为排除链表中null存在造成空指向,用data.equals(this.data)

- 数据删除

> 删除链表中指定的内容，删除的逻辑依靠的是引用的改变。对于集合数据删除分为两种情况：

> - 要删除的是根节点数据：改变root节点指向
>
> - 不是根节点数据：当前节点上一个next指向当前的next

- 清空链表

> 只要root设置为空，那么后续节点都不存在了

```java
interface ILink<E>{
	public void add(E e);//保存数据
	public int size();//统计数据
	public boolean isEmpty();//判断是否为空集合
	public Object[] toArray();//返回对象数组
	public E get(int index);//根据指定索引获取数据
	public void set(int index,E data);//修改指定索引的数据
	public boolean contains(E data);//判断链表是否含有指定元素
	public void remove(E data);//删除指定数据
	public void clean();//清空链表数据
}
class ILinkImpl<E> implements ILink<E>{//定义数据保存类，发号施令
	private class Node{//定义节点类，负责数据引用关系
		private E data;//保存数据
		private Node next;//保存下一个引用
		public Node(E data) {
			this.data = data;
		}
		//第一次由root调用(this=root)
		//第二次由root.next调用
		public void addNode(Node newnode) {
			if(this.next == null) {
				this.next = newnode;//从root开始问后面有位置吗
			}else {
				this.next.addNode(newnode);//嵌套问后面的后面有位置吗
			}
		}
		public void toNodeArray() {//内部类调用外部类属性:外部类.this.属性
			ILinkImpl.this.returnArray[ILinkImpl.this.foot++] = this.data;
			if(this.next != null) {//还有下一个数据
				this.next.toNodeArray();//递归调用
			}	
		}
		public E getNode(int index) {
			if(ILinkImpl.this.foot++ == index) {//配对成功
				return this.data;
			}else {
				return this.next.getNode(index);//链表继续匹配
			}
		}
		public void setNode(int index,E data) {
			if(ILinkImpl.this.foot++ == index) {//配对成功
				this.data = data;
			}else {
				this.next.setNode(index, data);
			}
		}
		public boolean containsNode(E data) {
			if(data.equals(this.data)) {//对象比较(排除含null干扰)
				return true;
			}else if(this.next == null){//没有后续节点了
				return false;
			}else {
				return this.next.containsNode(data);
			}
		}
		public void removeNode(Node previous,E data) {
			if(data.equals(this.data)){//第一次调用为root.next
				previous.next = this.next;//空出当前节点
			}else {
				if(this.next != null) {//还有后续节点
					this.next.removeNode(this, data);
				}
			}
		}
		
	}
	
	private Node root;//保存根元素
	private int count;//统计集合长度
	private Object[] returnArray;//返回数组
	private int foot;//数组脚标
	public void add(E e) {
		if(e == null) {
			return;//增加数据为空时直接返回
		}
		Node newnode = new Node(e);
		if(this.root == null) {//根节点不存在时
			this.root = newnode;
		}else {//根节点存在
			this.root.addNode(newnode);//由方法决定保存位置
		}
		count ++;
	}
	public int size() {
		return this.count;
	}
	public boolean isEmpty() {
		return root==null;
	}
	public Object[] toArray() {
		if(this.isEmpty()) {//空集合判断
			return null;
		}else {
			foot = 0;
			this.returnArray = new Object[this.count];
			this.root.toNodeArray();//利用Node类进行递归数据获取
			return this.returnArray;
		}
	}
	public E get(int index) {
		if(index >= this.count) {
			return null;
		}else {
			this.foot = 0;//重置脚标
			return this.root.getNode(index);//利用Node类从头比对获取
		}
	}
	public void set(int index,E data) {
		if(index >= this.count) {
			return;
		}else {
			this.foot = 0;
			this.root.setNode(index,data);
		}
	}
	public boolean contains(E data) {
		if(data == null) {
			return false;//数据为空
		}else {
			return this.root.containsNode(data);
		}
	}
	public void remove(E data) {
		if(this.contains(data)) {//判断数据是否存在
			if(data.equals(this.root.data)) {//根节点为要删除数据
				this.root = this.root.next;
			}else {
				this.root.next.removeNode(root,data);//调用Node删除后续节点
			}
		}else {
			return;
		}
		count -- ;
	}
	public void clean() {
		this.count = 0;
		this.root = null;//后续节点将不复存在
	}
}

public class Linkdemo {
	public static void main(String[] args) {
		ILink<String> link = new ILinkImpl<String>();
		link.add("Hello");
		link.add(",");
		link.add("world");
		link.remove(",");
		link.clean();
        //link.set(0, "你好");
		System.out.println(link.size());
		//System.out.println(link.isEmpty());
		Object[] obj = link.toArray();
		if(obj != null) {
			for(Object temp:obj) {
				System.out.println(temp);
			}
		}
//		System.out.println(link.contains("world"));
		//System.out.println(link.get(1));
	}
}
```

#### 21.1宠物商店

​		有一个宠物商店里面出售各种宠物，要求实现宠物上架、下架与根据关键词查询宠物信息。

![image-20211106165020350](.\markdownpicture\面向对象编程_1\image-20211106165020350.png)

```java
//定义宠物标准
interface Pet{
	public String getName();
	public String getColor();
}
class Petshop{
	ILink<Pet> allpets = new ILinkImpl<Pet>();//保存动态所有宠物信息
	//宠物上架
	public void add(Pet pet) {
		allpets.add(pet);
	}
	//宠物下架
	public void delete(Pet pet) {
		allpets.remove(pet);
	}
	//根据关键词查询宠物信息
	public ILink<Pet> search(String keywords){
		ILink<Pet> searchResult = new ILinkImpl<Pet>();//保存动态查询结果
		Object[] result = this.allpets.toArray();//保存入数组
		if(result != null) {
			for(Object obj:result) {
				Pet pet = (Pet) obj;//向下转型
				if(pet.getName().contains(keywords) || pet.getColor().contains(keywords)) {
					searchResult.add(pet);
				}
			}
		}
		return searchResult;
	}
}
//实现宠物标准
class Dog implements Pet{
	private String name;
	private String color;
	public Dog(String name,String color) {
		this.color = color;
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	public String getColor() {
		return this.color;
	}
	//因为要进行对象内容比较，所以要覆写equals()类
	@Override
	public boolean equals(Object obj) {
		if(obj == null) {
			return false;
		}
		if(!(obj instanceof Dog)) {//如果obj不是Dog类的对象
			return false;
		}
		if(this == obj) {
			return true;
		}
		Dog dog = (Dog) obj;//强制向下转型
		return this.name.equals(dog.name) && this.color.equals(dog.color);
	}
	
	public String toString() {
		return "【狗】宠物名字:"+this.name+"、宠物颜色:"+this.color;
	}
}
class Cat implements Pet{
	private String name;
	private String color;
	public Cat(String name,String color) {
		this.name = name;
		this.color = color;
	}
	public String getName() {
		return this.name;
	}
	public String getColor() {
		return this.color;
	}
	@Override
	public boolean equals(Object obj) {
		if(obj == null) {
			return false;
		}
		if(this == obj) {
			return true;
		}
		if(!(obj instanceof Cat)) {
			return false;
		}
		Cat cat = (Cat) obj;
		return this.name.equals(cat.name) && this.color.equals(cat.color);
	}
	public String toString() {
		return "【猫】宠物名字:"+this.name+"、宠物颜色:"+this.color;
	}
}
public class Linkdemo {
	public static void main(String[] args) {
		Petshop shop = new Petshop();
		shop.add(new Dog("黄斑狗","绿色"));
		shop.add(new Cat("小强猫","深绿色"));
		shop.add(new Cat("黄猫","深色"));
		shop.add(new Dog("黄狗","黄色"));
		shop.add(new Dog("斑点狗","灰色"));
		Object[] result = shop.search("黄").toArray();
		for(Object obj:result) {
			System.out.println(obj);
		}
	}
}
```

**必须覆写equals()方法,不然无法进行对象内容比较,默认的是比较地址**

所有的程序开发都是以接口为标准进行的，这样在进行后期程序的时候就可以非常的灵活，只要符合标准的对象都可以保存。

#### 21.2购物车

​		使用面向对象的概念表示出下面的生活场景：小明去超市买东西，所有买到的东西都放在了购物车之中，最后到收银台一起结账。

用购物车标准来降低耦合：即特殊性，分大、小购物车

![在这里插入图片描述](.\markdownpicture\面向对象编程_1\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlbmlkaTgyMTU=,size_16,color_FFFFFF,t_70)

```java
interface IGoods{//商品标准
	public String getName();
	public double getPrice();
}
interface IShopcar{//购物车标准
	public void add(IGoods good);
	public void delete(IGoods good);
	public Object[] getAll();
}
class Shopcar implements IShopcar{
	ILink<IGoods> allgoods = new ILinkImpl<IGoods>();//定义动态商品链表
	public void add(IGoods good) {
		allgoods.add(good);
	}
	public void delete(IGoods good) {
		allgoods.remove(good);
	}
	public Object[] getAll() {
		return allgoods.toArray();
	}
}
class Cashier{
	private IShopcar shopcar;
	public Cashier(IShopcar shopcar) {
		this.shopcar = shopcar;
	}
	public double getAllPrice() {
		double sum = 0.0;
		Object[] result = shopcar.getAll();//获得对象数组
		for(Object obj:result) {
			IGoods good = (IGoods)obj;
			sum += good.getPrice();
		}
		return sum;
	}
	public int getAllCount() {
		return this.shopcar.getAll().length;//获取链表长度
	}
}
class Book implements IGoods{
	private String name;
	private double price;
	public Book(String name, double price) {
		this.name = name;
		this.price = price;
	}
	public String getName() {
		return this.name;
	}
	public double getPrice() {
		return this.price;
	}
	@Override
	public boolean equals(Object obj) {
		if(obj == null) {
			return false;
		}
		if(obj == this) {
			return true;
		}
		if(!(obj instanceof Book)) {
			return false;
		}
		Book book = (Book) obj;
		return this.price==book.price && this.name.equals(book.name);
	}
	public String toString() {
		return "【图书】名称:"+this.name+"、价格:"+this.price;
	}
}
class Bag implements IGoods{
	private String name;
	private double price;
	public Bag(String name, double price) {
		this.name = name;
		this.price = price;
	}
	public String getName() {
		return this.name;
	}
	public double getPrice() {
		return this.price;
	}
	@Override
	public boolean equals(Object obj) {
		if(obj == null) {
			return false;
		}
		if(obj == this) {
			return true;
		}
		if(!(obj instanceof Book)) {
			return false;
		}
		Bag bag = (Bag) obj;
		return this.price==bag.price && this.name.equals(bag.name);
	}
	public String toString() {
		return "【书包】名称:"+this.name+"、价格:"+this.price;
	}
}


public class Shopmall {
	public static void main(String[] args) {
		IShopcar shopcar = new Shopcar();//开购物车
		shopcar.add(new Book("Java开发",79.8));
		shopcar.add(new Book("Oracle开发",89.8));
		shopcar.add(new Bag("小强背包",889.8));
		Cashier cash = new Cashier(shopcar);
		System.out.println("总价格:"+cash.getAllPrice());
		System.out.println("总数量:"+cash.getAllCount());
		
	}
}
```

### 二十二、开发工具

- Eclipse开发工具+windows操作系统+Tomcat中间件+MySql数据库
- Eclipse所有设置是针对工作区的，更换工作区后会恢复设置
- 支持Junit测试、CVS客户端、插件开发功能
- Eclipse常用快捷键：
  - CTRL+1:进行代码纠正提示;
  - ALT+/：进行代码提示;  main+alt+/生成主方法    syso+alt+/生成输出
  - CTRL+SHIFT+F：格式化代码;
  - CTRL+SHIFT+O：自动导入所需要的包
  - CTRL+SHIFT+L:快捷键大全
- 可以进行getter(),setter(),构造方法、toString()、equals()方法的源码生成
- 使用初始化参数进行内容的接收时，要执行一次后去运行配置中设置程序自变量
- 使用Eclipse还可以直接将类导出为*.jar文件：[File] — [Export] — [导出为JAR文件] — [选择要导出的文件内容并且设置文件名称]
- **要提供外部包导入，首先访问权限得定义为public :**导入jar文件：右键项目--->属性--->Java构建路径---->库
- 构造方法私有化后，外部不可实例化对象

```java
class Math {
	private Math() {
	}//构造方法对外部不可视
	public static int add(int x,int y) {
		int result = 0;
		result = x + y;
		return result;
	}
}
```

#### 22.1 调试

- 如果要进行代码调试，那么一定要保证设置有一个程序的断点(**调试从断点开始**)
  - 单步跳入(F5)：进入到代码之中进行程序调用等的观察；
  - 单步跳过(F6)：只关心结果不关心到底执行什么(观察表面执行)；不进入具体类
  - 单步返回(F7)：进入之后不再观察，则直接返回；
  - 恢复执行(F8)：取消断点的影响，程序正常执行完毕

#### 22.2 junit测试工具

> 在进行测试的时候除了白盒测试与黑盒测试之外，现在最流行的是用例测试，而JUnit实现的就是一个用例测试(举例子)的工具。

- 黑盒测试：与软件实现无关，也称为用户角度进行功能测试
- 白盒测试：检查软件内部逻辑

> junit是一个第三方的组件包，所以需要在JavaBuilderPath中配置相应的程序库，使用Eclipse可以帮助开发者自己来配置*.jar文件的CLASSPATH环境

流程：选中要测试的类-->新建Junit测试用例-->选好包-->编写测试代码

```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;
import zju.edu.tool.MathUtil;

class TestdemoTest {
	@Test
	void test() {
		assertEquals(MathUtil.add(1,2), 3);
	}
}
```

测试结果有两个：成功（Green Bar）、失败（Red Bar）。



后不再观察，则直接返回；
  - 恢复执行(F8)：取消断点的影响，程序正常执行完毕

#### 22.2 junit测试工具

> 在进行测试的时候除了白盒测试与黑盒测试之外，现在最流行的是用例测试，而JUnit实现的就是一个用例测试(举例子)的工具。

- 黑盒测试：与软件实现无关，也称为用户角度进行功能测试
- 白盒测试：检查软件内部逻辑

> junit是一个第三方的组件包，所以需要在JavaBuilderPath中配置相应的程序库，使用Eclipse可以帮助开发者自己来配置*.jar文件的CLASSPATH环境

流程：选中要测试的类-->新建Junit测试用例-->选好包-->编写测试代码

```java
import static org.junit.jupiter.api.Assertion